{"version":3,"sources":["RoundRobin.ts","VoiceDetector.ts","worker.ts"],"names":[],"mappings":";AA+Ce,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAzCf,IAAA,EAAA,WAIE,SAAA,EAAY,GAFJ,KAAA,OAAiB,EAGlB,KAAA,OAAS,IAAI,aAAa,GAC1B,KAAA,OAAS,EAiClB,OA9BE,EAAA,UAAA,MAAA,SAAM,GACA,KAAK,OAAS,EAAK,OAAS,KAAK,OAAO,QACrC,KAAA,OAAO,IACV,EAAK,SAAS,EAAG,KAAK,OAAO,OAAS,KAAK,QAC3C,KAAK,QAEF,KAAA,OAAO,IAAI,EAAK,SAAS,KAAK,OAAO,OAAS,KAAK,SACnD,KAAA,OAAS,KAAK,OAAO,OAAS,KAAK,SAEnC,KAAA,OAAO,IAAI,EAAM,KAAK,QACtB,KAAA,QAAU,EAAK,SAIxB,EAAA,UAAA,SAAA,SAAS,GAGH,IAFK,EAAA,KAAK,IAAI,KAAK,OAAO,OAAQ,KAExB,KAAK,OACV,OAAA,KAAK,OAAO,MAAM,KAAK,OAAS,EAAQ,KAAK,QAGhD,IAAA,EAAS,IAAI,aAAa,GAOzB,OALA,EAAA,IACL,KAAK,OAAO,SAAS,KAAK,OAAO,QAAU,EAAS,KAAK,UAEpD,EAAA,IAAI,KAAK,OAAO,SAAS,EAAG,KAAK,QAAS,EAAS,KAAK,QAExD,GAEX,EAvCA,GAyCe,QAAA,WAAA,EAAA,QAAA,QAAA;;AClBA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAvBf,IAAA,EAAA,WAME,SAAA,EAAY,EAAmB,GAFvB,KAAA,IAAc,EAGf,KAAA,YAAc,EACd,KAAA,UAAY,EAarB,OAVE,EAAA,UAAA,MAAA,SAAM,GACE,IAAA,EAAM,EAAK,IAAI,KAAK,KAAK,OAAO,SAAC,EAAG,GAAM,OAAA,EAAI,IAE/C,KAAA,KAAO,EAAI,EAAK,OAAS,KAAK,YAC9B,KAAA,KAAO,EAAM,KAAK,aAGzB,EAAA,UAAA,eAAA,WACS,OAAA,KAAK,IAAM,KAAK,WAE3B,EArBA,GAuBe,QAAA,8BAAA,EAAA,QAAA,QAAA;;ACXf,aAlBA,IAAA,EAAA,QAAA,gBAkBA,EAAA,EAAA,GAjBA,EAAA,QAAA,mBAiBA,EAAA,EAAA,GAAA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAfA,IAAM,EAAsB,IACtB,EAAc,MACd,EAAe,GACf,EAAmB,GAEnB,EAAc,KACd,EAAS,IAAI,EAAJ,QAAe,EAAe,GACvC,EAAgB,IAAI,EAAJ,QACpB,EACA,EAAmB,GAGjB,GAAY,EACZ,EAAgB,EAEpB,EAAI,UAAY,SAAA,GACR,IAAA,EAAoB,EAAE,KAEd,EAAA,MAAM,GACb,EAAA,MAAM,GAEP,IAAA,EAAiB,EAAc,iBAWjC,IATC,GAAa,GACJ,GAAA,EACI,EAAA,EAEZ,EAAA,YAAY,CAAE,KAAM,iBACf,IACQ,GAAA,EAAI,QAGnB,IAAc,EAAgB,CAC1B,IAAA,EAAQ,EAAO,SACnB,EAAgB,EAAmB,GAGjC,EAAA,YAAY,CACR,KAAA,YACG,QAAA,IAGC,GAAA","file":"worker.427e8fc8.map","sourceRoot":"..","sourcesContent":["export interface IRoundRobin {\n  write(data: Float32Array): void;\n\n  readLast(length: number): Float32Array;\n}\n\nexport class RoundRobin implements IRoundRobin {\n  private readonly buffer: Float32Array;\n  private offset: number = 0;\n\n  constructor(size: number) {\n    this.buffer = new Float32Array(size);\n    this.offset = 0;\n  }\n\n  write(data: Float32Array) {\n    if (this.offset + data.length > this.buffer.length) {\n      this.buffer.set(\n        data.subarray(0, this.buffer.length - this.offset),\n        this.offset\n      );\n      this.buffer.set(data.subarray(this.buffer.length - this.offset));\n      this.offset = this.buffer.length - this.offset;\n    } else {\n      this.buffer.set(data, this.offset);\n      this.offset += data.length;\n    }\n  }\n\n  readLast(length: number): Float32Array {\n    length = Math.min(this.buffer.length, length);\n\n    if (length <= this.offset) {\n      return this.buffer.slice(this.offset - length, this.offset);\n    }\n\n    const output = new Float32Array(length);\n\n    output.set(\n      this.buffer.subarray(this.buffer.length - (length - this.offset))\n    );\n    output.set(this.buffer.subarray(0, this.offset), length - this.offset);\n\n    return output;\n  }\n}\n\nexport default RoundRobin;\n","export interface IVoiceDetector {\n  write(data: Float32Array): void;\n\n  isHearingVoice(): boolean;\n}\n\nexport class AverageAmplitudeVoiceDetector implements IVoiceDetector {\n  private readonly sampleCount: number;\n  private readonly threshold: number;\n\n  private avg: number = 0;\n\n  constructor(threshold: number, sampleCount: number) {\n    this.sampleCount = sampleCount;\n    this.threshold = threshold;\n  }\n\n  write(data: Float32Array) {\n    const sum = data.map(Math.abs).reduce((a, b) => a + b);\n\n    this.avg *= 1 - data.length / this.sampleCount;\n    this.avg += sum / this.sampleCount;\n  }\n\n  isHearingVoice() {\n    return this.avg > this.threshold;\n  }\n}\n\nexport default AverageAmplitudeVoiceDetector;\n","import RoundRobin from \"./RoundRobin\";\nimport VoiceDetector from \"./VoiceDetector\";\n\nconst AMPLITUDE_THRESHOLD = 0.02;\nconst SAMPLE_RATE = 44100;\nconst MAX_DURATION = 60;\nconst SILENCE_DURATION = 0.5;\n\nconst ctx: Worker = self as any;\nconst buffer = new RoundRobin(MAX_DURATION * SAMPLE_RATE);\nconst voiceDetector = new VoiceDetector(\n  AMPLITUDE_THRESHOLD,\n  SILENCE_DURATION * SAMPLE_RATE\n);\n\nlet recording = false;\nlet recordingSize = 0;\n\nctx.onmessage = e => {\n  const pcm: Float32Array = e.data;\n\n  voiceDetector.write(pcm);\n  buffer.write(pcm);\n\n  const isHearingVoice = voiceDetector.isHearingVoice();\n\n  if (!recording && isHearingVoice) {\n    recording = true;\n    recordingSize = 0;\n\n    ctx.postMessage({ type: \"voice_start\" });\n  } else if (recording) {\n    recordingSize += pcm.length;\n  }\n\n  if (recording && !isHearingVoice) {\n    const audio = buffer.readLast(\n      recordingSize + SILENCE_DURATION * SAMPLE_RATE\n    );\n\n    ctx.postMessage({\n      type: \"voice_end\",\n      payload: audio\n    });\n\n    recording = false;\n  }\n};\n"]}