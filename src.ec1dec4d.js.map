{"version":3,"sources":["../src/htmldomapi.ts","../src/vnode.ts","../src/is.ts","../src/init.ts","../src/h.ts","../src/thunk.ts","../../src/helpers/attachto.ts","../src/tovnode.ts","../../src/modules/attributes.ts","../../src/modules/class.ts","../../src/modules/dataset.ts","../../src/modules/eventlisteners.ts","../../src/modules/props.ts","../../src/modules/style.ts","../src/jsx.ts","../src/index.ts","../../src/thunk.ts","../../src/adapt.ts","node_modules/symbol-observable/es/ponyfill.js","node_modules/symbol-observable/es/index.js","src/index.ts","../../src/fromEvent.ts","../../src/DocumentDOMSource.ts","../../src/BodyDOMSource.ts","../../src/utils.ts","../../src/ScopeChecker.ts","../../src/ElementFinder.ts","../../src/isolate.ts","../../src/MainDOMSource.ts","../src/extra/concat.ts","../src/extra/sampleCombine.ts","../../src/curry2.ts","../../src/selectorParser.ts","../../src/matches.ts","../../src/querySelector.ts","../../src/index.ts","../../src/classNameFromVNode.ts","../../src/parent-symbol.ts","../../src/query.ts","../../src/findMatches.ts","../../src/VNodeWrapper.ts","../../src/modules.ts","../../src/SymbolTree.ts","../../src/IsolateModule.ts","../../src/PriorityQueue.ts","../../src/EventDelegator.ts","../../src/makeDOMDriver.ts","../../src/mockDOMSource.ts","../../src/hyperscript-helpers.ts","node_modules/process/browser.js","index.ts","../../src/internals.ts","node_modules/@cycle/storage/lib/writeToStore.js","../src/extra/dropRepeats.ts","node_modules/@cycle/storage/lib/util.js","node_modules/@cycle/storage/lib/responseCollection.js","node_modules/@cycle/storage/lib/index.js","node_modules/extend/index.js","node_modules/snabbdom-pragma/dist/index.es6.js","src/utils.ts","src/components/LabeledSlider.ts","src/components/ToggleButton.ts","src/components/Main.tsx","src/drivers/audioDriver.ts","src/drivers/workerDriver.ts","src/index.tsx"],"names":["symbolObservablePonyfill","root","result","Symbol","observable","_ponyfill","_interopRequireDefault","require","obj","__esModule","default","self","window","global","module","Function","ponyfill","_default","exports","cachedSetTimeout","cachedClearTimeout","process","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","call","runClearTimeout","marker","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","Item","array","noop","nextTick","args","Array","arguments","i","push","prototype","apply","title","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","writeToStore","request","_a","target","_b","action","key","value","localStorage","sessionStorage","Object","defineProperty","xstream_1","dropRepeats_1","adapt_1","extStorageProducer","start","listener","sendReq","storage","next","newValue","addEventListener","stop","removeEventListener","extStorage$","create","never","getStorage$","request$","type","merge","filter","req","storageKey","n","storage$","map","startWith","compose","storageGetItem","storageObj","getItem","getResponseObj","adapt","util_1","default_1","writeToStore_1","responseCollection_1","storageDriver","_extend2","undefinedv","v","undefined","number","string","text","isArray","object","vnode","svgPropsMap","svg","circle","ellipse","line","polygon","polyline","rect","g","path","sel","extend","objs","_extend","assign","reduceDeep","arr","fn","initial","mapObject","keys","reduce","acc","curr","deepifyKeys","val","obj$1","dashIndex","indexOf","moduleData","slice","flatifyKeys","mod","data","omit","createTextElement","text$$1","children","elm","considerSvg","vnode$$1","ns","attrs","props","class","className","child","considerData","considerAria","aria","considerProps","rewritesMap","for","role","tabindex","considerAttrs","considerKey","sanitizeData","sanitizeText","sanitizeChildren","createElement","index"],"mappings":"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O,SAAqB,EAAQ,EAAS,GAC3C,IAAM,OAAoB,IAAN,EACd,OAAoB,IAAN,EACd,OAAoB,IAAN,EACpB,OAAI,EAAW,GACT,GAAQ,GACH,EAAA,EAAC,GAAC,EAAU,EAAG,EAAG,GAChB,GACF,EAAA,EAAC,GAAC,EAAU,EAAG,IAEf,EAAA,EAAC,GAAC,EAAU,EAAG,IAEf,GACF,EAAA,EAAC,GAAC,EAAU,EAAG,EAAG,GAChB,GACF,EAAA,EAAC,GAAC,EAAS,EAAG,GACZ,GACF,EAAA,EAAC,GAAC,EAAS,IAEX,EAAA,EAAC,GAAC,EAAS,KAKxB,IAAM,EAAgB,CACpB,IACA,WACA,cACA,eACA,UACA,eACA,gBACA,mBACA,SACA,WACA,eACA,SACA,OACA,OACA,UACA,UACA,gBACA,sBACA,cACA,mBACA,oBACA,oBACA,iBACA,UACA,UACA,UACA,UACA,UACA,iBACA,UACA,UACA,cACA,eACA,WACA,eACA,qBACA,cACA,SACA,eACA,SACA,OACA,WACA,iBACA,eACA,cACA,cACA,gBACA,IACA,QACA,WACA,QACA,QACA,OACA,iBACA,SACA,OACA,WACA,eACA,QACA,OACA,UACA,UACA,WACA,iBACA,OACA,SACA,MACA,OACA,QACA,SACA,SACA,OACA,WACA,QACA,OACA,QACA,MACA,OACA,SAGI,EAAM,EAAkB,OAE9B,EAAc,QAAQ,SAAA,GACpB,EAAI,GAAO,EAAkB,KAG/B,IAAM,EAAY,CAChB,IACA,OACA,UACA,OACA,UACA,QACA,QACA,IACA,OACA,MACA,MACA,aACA,OACA,KACA,SACA,SACA,UACA,OACA,OACA,MACA,WACA,KACA,MACA,UACA,MACA,MACA,MACA,KACA,KACA,KACA,QACA,WACA,aACA,SACA,SACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,SACA,SACA,KACA,OACA,IACA,SACA,MACA,QACA,MACA,MACA,SACA,QACA,SACA,KACA,OACA,OACA,MACA,OACA,OACA,OACA,MACA,WACA,SACA,KACA,WACA,SACA,IACA,QACA,MACA,WA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","file":"src.ec1dec4d.js","sourceRoot":"..","sourcesContent":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"import $$observable from 'symbol-observable';\n\nconst NO = {};\nfunction noop() {}\n\nfunction cp<T>(a: Array<T>): Array<T> {\n  const l = a.length;\n  const b = Array(l);\n  for (let i = 0; i < l; ++i) b[i] = a[i];\n  return b;\n}\n\nfunction and<T>(f1: (t: T) => boolean, f2: (t: T) => boolean): (t: T) => boolean {\n  return function andFn(t: T): boolean {\n    return f1(t) && f2(t);\n  };\n}\n\ninterface FContainer<T, R> {\n  f(t: T): R;\n}\n\nfunction _try<T, R>(c: FContainer<T, R>, t: T, u: Stream<any>): R | {} {\n  try {\n    return c.f(t);\n  } catch (e) {\n    u._e(e);\n    return NO;\n  }\n}\n\nexport interface InternalListener<T> {\n  _n: (v: T) => void;\n  _e: (err: any) => void;\n  _c: () => void;\n}\n\nconst NO_IL: InternalListener<any> = {\n  _n: noop,\n  _e: noop,\n  _c: noop,\n};\n\nexport interface InternalProducer<T> {\n  _start(listener: InternalListener<T>): void;\n  _stop: () => void;\n}\n\nexport interface OutSender<T> {\n  out: Stream<T>;\n}\n\nexport interface Operator<T, R> extends InternalProducer<R>, InternalListener<T>, OutSender<R> {\n  type: string;\n  ins: Stream<T>;\n  _start(out: Stream<R>): void;\n}\n\nexport interface Aggregator<T, U> extends InternalProducer<U>, OutSender<U> {\n  type: string;\n  insArr: Array<Stream<T>>;\n  _start(out: Stream<U>): void;\n}\n\nexport interface Producer<T> {\n  start: (listener: Listener<T>) => void;\n  stop: () => void;\n}\n\nexport interface Listener<T> {\n  next: (x: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\nexport interface Subscription {\n  unsubscribe(): void;\n}\n\nexport interface Observable<T> {\n  subscribe(listener: Listener<T>): Subscription;\n}\n\n// mutates the input\nfunction internalizeProducer<T>(producer: Producer<T> & Partial<InternalProducer<T>>) {\n  producer._start = function _start(il: InternalListener<T> & Partial<Listener<T>>) {\n    il.next = il._n;\n    il.error = il._e;\n    il.complete = il._c;\n    this.start(il);\n  };\n  producer._stop = producer.stop;\n}\n\nclass StreamSub<T> implements Subscription {\n  constructor(private _stream: Stream<T>, private _listener: InternalListener<T>) {}\n\n  unsubscribe(): void {\n    this._stream._remove(this._listener);\n  }\n}\n\nclass Observer<T> implements Listener<T> {\n  constructor(private _listener: InternalListener<T>) {}\n\n  next(value: T) {\n    this._listener._n(value);\n  }\n\n  error(err: any) {\n    this._listener._e(err);\n  }\n\n  complete() {\n    this._listener._c();\n  }\n}\n\nclass FromObservable<T> implements InternalProducer<T> {\n  public type = 'fromObservable';\n  public ins: Observable<T>;\n  public out: Stream<T>;\n  private active: boolean;\n  private _sub: Subscription | undefined;\n\n  constructor(observable: Observable<T>) {\n    this.ins = observable;\n    this.active = false;\n  }\n\n  _start(out: Stream<T>) {\n    this.out = out;\n    this.active = true;\n    this._sub = this.ins.subscribe(new Observer(out));\n    if (!this.active) this._sub.unsubscribe();\n  }\n\n  _stop() {\n    if (this._sub) this._sub.unsubscribe();\n    this.active = false;\n  }\n}\n\nexport interface MergeSignature {\n  (): Stream<any>;\n  <T1>(s1: Stream<T1>): Stream<T1>;\n  <T1, T2>(\n    s1: Stream<T1>,\n    s2: Stream<T2>): Stream<T1 | T2>;\n  <T1, T2, T3>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>): Stream<T1 | T2 | T3>;\n  <T1, T2, T3, T4>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>): Stream<T1 | T2 | T3 | T4>;\n  <T1, T2, T3, T4, T5>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>): Stream<T1 | T2 | T3 | T4 | T5>;\n  <T1, T2, T3, T4, T5, T6>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>): Stream<T1 | T2 | T3 | T4 | T5 | T6>;\n  <T1, T2, T3, T4, T5, T6, T7>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>): Stream<T1 | T2 | T3 | T4 | T5 | T6 | T7>;\n  <T1, T2, T3, T4, T5, T6, T7, T8>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>): Stream<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\n  <T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>,\n    s9: Stream<T9>): Stream<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\n  <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>,\n    s9: Stream<T9>,\n    s10: Stream<T10>): Stream<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10>;\n  <T>(...stream: Array<Stream<T>>): Stream<T>;\n}\n\nclass Merge<T> implements Aggregator<T, T>, InternalListener<T> {\n  public type = 'merge';\n  public insArr: Array<Stream<T>>;\n  public out: Stream<T>;\n  private ac: number; // ac is activeCount\n\n  constructor(insArr: Array<Stream<T>>) {\n    this.insArr = insArr;\n    this.out = NO as Stream<T>;\n    this.ac = 0;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    const s = this.insArr;\n    const L = s.length;\n    this.ac = L;\n    for (let i = 0; i < L; i++) s[i]._add(this);\n  }\n\n  _stop(): void {\n    const s = this.insArr;\n    const L = s.length;\n    for (let i = 0; i < L; i++) s[i]._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    if (--this.ac <= 0) {\n      const u = this.out;\n      if (u === NO) return;\n      u._c();\n    }\n  }\n}\n\nexport interface CombineSignature {\n  (): Stream<Array<any>>;\n  <T1>(s1: Stream<T1>): Stream<[T1]>;\n  <T1, T2>(\n    s1: Stream<T1>,\n    s2: Stream<T2>): Stream<[T1, T2]>;\n  <T1, T2, T3>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>): Stream<[T1, T2, T3]>;\n  <T1, T2, T3, T4>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>): Stream<[T1, T2, T3, T4]>;\n  <T1, T2, T3, T4, T5>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>): Stream<[T1, T2, T3, T4, T5]>;\n  <T1, T2, T3, T4, T5, T6>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>): Stream<[T1, T2, T3, T4, T5, T6]>;\n  <T1, T2, T3, T4, T5, T6, T7>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>): Stream<[T1, T2, T3, T4, T5, T6, T7]>;\n  <T1, T2, T3, T4, T5, T6, T7, T8>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>): Stream<[T1, T2, T3, T4, T5, T6, T7, T8]>;\n  <T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>,\n    s9: Stream<T9>): Stream<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;\n  <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>,\n    s9: Stream<T9>,\n    s10: Stream<T10>): Stream<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;\n  (...stream: Array<Stream<any>>): Stream<Array<any>>;\n}\n\nclass CombineListener<T> implements InternalListener<T>, OutSender<Array<T>> {\n  private i: number;\n  public out: Stream<Array<T>>;\n  private p: Combine<T>;\n\n  constructor(i: number, out: Stream<Array<T>>, p: Combine<T>) {\n    this.i = i;\n    this.out = out;\n    this.p = p;\n    p.ils.push(this);\n  }\n\n  _n(t: T): void {\n    const p = this.p, out = this.out;\n    if (out === NO) return;\n    if (p.up(t, this.i)) {\n      const a = p.vals;\n      const l = a.length;\n      const b = Array(l);\n      for (let i = 0; i < l; ++i) b[i] = a[i];\n      out._n(b);\n    }\n  }\n\n  _e(err: any): void {\n    const out = this.out;\n    if (out === NO) return;\n    out._e(err);\n  }\n\n  _c(): void {\n    const p = this.p;\n    if (p.out === NO) return;\n    if (--p.Nc === 0) p.out._c();\n  }\n}\n\nclass Combine<R> implements Aggregator<any, Array<R>> {\n  public type = 'combine';\n  public insArr: Array<Stream<any>>;\n  public out: Stream<Array<R>>;\n  public ils: Array<CombineListener<any>>;\n  public Nc: number; // *N*umber of streams still to send *c*omplete\n  public Nn: number; // *N*umber of streams still to send *n*ext\n  public vals: Array<R>;\n\n  constructor(insArr: Array<Stream<any>>) {\n    this.insArr = insArr;\n    this.out = NO as Stream<Array<R>>;\n    this.ils = [];\n    this.Nc = this.Nn = 0;\n    this.vals = [];\n  }\n\n  up(t: any, i: number): boolean {\n    const v = this.vals[i];\n    const Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;\n    this.vals[i] = t;\n    return Nn === 0;\n  }\n\n  _start(out: Stream<Array<R>>): void {\n    this.out = out;\n    const s = this.insArr;\n    const n = this.Nc = this.Nn = s.length;\n    const vals = this.vals = new Array(n);\n    if (n === 0) {\n      out._n([]);\n      out._c();\n    } else {\n      for (let i = 0; i < n; i++) {\n        vals[i] = NO;\n        s[i]._add(new CombineListener(i, out, this));\n      }\n    }\n  }\n\n  _stop(): void {\n    const s = this.insArr;\n    const n = s.length;\n    const ils = this.ils;\n    for (let i = 0; i < n; i++) s[i]._remove(ils[i]);\n    this.out = NO as Stream<Array<R>>;\n    this.ils = [];\n    this.vals = [];\n  }\n}\n\nclass FromArray<T> implements InternalProducer<T> {\n  public type = 'fromArray';\n  public a: Array<T>;\n\n  constructor(a: Array<T>) {\n    this.a = a;\n  }\n\n  _start(out: InternalListener<T>): void {\n    const a = this.a;\n    for (let i = 0, n = a.length; i < n; i++) out._n(a[i]);\n    out._c();\n  }\n\n  _stop(): void {\n  }\n}\n\nclass FromPromise<T> implements InternalProducer<T> {\n  public type = 'fromPromise';\n  public on: boolean;\n  public p: PromiseLike<T>;\n\n  constructor(p: PromiseLike<T>) {\n    this.on = false;\n    this.p = p;\n  }\n\n  _start(out: InternalListener<T>): void {\n    const prod = this;\n    this.on = true;\n    this.p.then(\n      (v: T) => {\n        if (prod.on) {\n          out._n(v);\n          out._c();\n        }\n      },\n      (e: any) => {\n        out._e(e);\n      },\n    ).then(noop, (err: any) => {\n      setTimeout(() => { throw err; });\n    });\n  }\n\n  _stop(): void {\n    this.on = false;\n  }\n}\n\nclass Periodic implements InternalProducer<number> {\n  public type = 'periodic';\n  public period: number;\n  private intervalID: any;\n  private i: number;\n\n  constructor(period: number) {\n    this.period = period;\n    this.intervalID = -1;\n    this.i = 0;\n  }\n\n  _start(out: InternalListener<number>): void {\n    const self = this;\n    function intervalHandler() { out._n(self.i++); }\n    this.intervalID = setInterval(intervalHandler, this.period);\n  }\n\n  _stop(): void {\n    if (this.intervalID !== -1) clearInterval(this.intervalID);\n    this.intervalID = -1;\n    this.i = 0;\n  }\n}\n\nclass Debug<T> implements Operator<T, T> {\n  public type = 'debug';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  private s: (t: T) => any; // spy\n  private l: string; // label\n\n  constructor(ins: Stream<T>);\n  constructor(ins: Stream<T>, arg?: string);\n  constructor(ins: Stream<T>, arg?: (t: T) => any);\n  constructor(ins: Stream<T>, arg?: string | ((t: T) => any));\n  constructor(ins: Stream<T>, arg?: string | ((t: T) => any) | undefined) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.s = noop;\n    this.l = '';\n    if (typeof arg === 'string') this.l = arg; else if (typeof arg === 'function') this.s = arg;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    const s = this.s, l = this.l;\n    if (s !== noop) {\n      try {\n        s(t);\n      } catch (e) {\n        u._e(e);\n      }\n    } else if (l) console.log(l + ':', t); else console.log(t);\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass Drop<T> implements Operator<T, T> {\n  public type = 'drop';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public max: number;\n  private dropped: number;\n\n  constructor(max: number, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.max = max;\n    this.dropped = 0;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.dropped = 0;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    if (this.dropped++ >= this.max) u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass EndWhenListener<T> implements InternalListener<any> {\n  private out: Stream<T>;\n  private op: EndWhen<T>;\n\n  constructor(out: Stream<T>, op: EndWhen<T>) {\n    this.out = out;\n    this.op = op;\n  }\n\n  _n() {\n    this.op.end();\n  }\n\n  _e(err: any) {\n    this.out._e(err);\n  }\n\n  _c() {\n    this.op.end();\n  }\n}\n\nclass EndWhen<T> implements Operator<T, T> {\n  public type = 'endWhen';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public o: Stream<any>; // o = other\n  private oil: InternalListener<any>; // oil = other InternalListener\n\n  constructor(o: Stream<any>, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.o = o;\n    this.oil = NO_IL;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.o._add(this.oil = new EndWhenListener(out, this));\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.o._remove(this.oil);\n    this.out = NO as Stream<T>;\n    this.oil = NO_IL;\n  }\n\n  end(): void {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    this.end();\n  }\n}\n\nclass Filter<T> implements Operator<T, T> {\n  public type = 'filter';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public f: (t: T) => boolean;\n\n  constructor(passes: (t: T) => boolean, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.f = passes;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    const r = _try(this, t, u);\n    if (r === NO || !r) return;\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass FlattenListener<T> implements InternalListener<T> {\n  private out: Stream<T>;\n  private op: Flatten<T>;\n\n  constructor(out: Stream<T>, op: Flatten<T>) {\n    this.out = out;\n    this.op = op;\n  }\n\n  _n(t: T) {\n    this.out._n(t);\n  }\n\n  _e(err: any) {\n    this.out._e(err);\n  }\n\n  _c() {\n    this.op.inner = NO as Stream<T>;\n    this.op.less();\n  }\n}\n\nclass Flatten<T> implements Operator<Stream<T>, T> {\n  public type = 'flatten';\n  public ins: Stream<Stream<T>>;\n  public out: Stream<T>;\n  private open: boolean;\n  public inner: Stream<T>; // Current inner Stream\n  private il: InternalListener<T>; // Current inner InternalListener\n\n  constructor(ins: Stream<Stream<T>>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.open = true;\n    this.inner = NO as Stream<T>;\n    this.il = NO_IL;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.open = true;\n    this.inner = NO as Stream<T>;\n    this.il = NO_IL;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    if (this.inner !== NO) this.inner._remove(this.il);\n    this.out = NO as Stream<T>;\n    this.open = true;\n    this.inner = NO as Stream<T>;\n    this.il = NO_IL;\n  }\n\n  less(): void {\n    const u = this.out;\n    if (u === NO) return;\n    if (!this.open && this.inner === NO) u._c();\n  }\n\n  _n(s: Stream<T>) {\n    const u = this.out;\n    if (u === NO) return;\n    const {inner, il} = this;\n    if (inner !== NO && il !== NO_IL) inner._remove(il);\n    (this.inner = s)._add(this.il = new FlattenListener(u, this));\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    this.open = false;\n    this.less();\n  }\n}\n\nclass Fold<T, R> implements Operator<T, R> {\n  public type = 'fold';\n  public ins: Stream<T>;\n  public out: Stream<R>;\n  public f: (t: T) => R;\n  public seed: R;\n  private acc: R; // initialized as seed\n\n  constructor(f: (acc: R, t: T) => R, seed: R, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<R>;\n    this.f = (t: T) => f(this.acc, t);\n    this.acc = this.seed = seed;\n  }\n\n  _start(out: Stream<R>): void {\n    this.out = out;\n    this.acc = this.seed;\n    out._n(this.acc);\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<R>;\n    this.acc = this.seed;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    const r = _try(this, t, u);\n    if (r === NO) return;\n    u._n(this.acc = r as R);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass Last<T> implements Operator<T, T> {\n  public type = 'last';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  private has: boolean;\n  private val: T;\n\n  constructor(ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.has = false;\n    this.val = NO as T;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.has = false;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n    this.val = NO as T;\n  }\n\n  _n(t: T) {\n    this.has = true;\n    this.val = t;\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    if (this.has) {\n      u._n(this.val);\n      u._c();\n    } else u._e(new Error('last() failed because input stream completed'));\n  }\n}\n\nclass MapOp<T, R> implements Operator<T, R> {\n  public type = 'map';\n  public ins: Stream<T>;\n  public out: Stream<R>;\n  public f: (t: T) => R;\n\n  constructor(project: (t: T) => R, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<R>;\n    this.f = project;\n  }\n\n  _start(out: Stream<R>): void {\n    this.out = out;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<R>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    const r = _try(this, t, u);\n    if (r === NO) return;\n    u._n(r as R);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass Remember<T> implements InternalProducer<T> {\n  public type = 'remember';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n\n  constructor(ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.ins._add(out);\n  }\n\n  _stop(): void {\n    this.ins._remove(this.out);\n    this.out = NO as Stream<T>;\n  }\n}\n\nclass ReplaceError<T> implements Operator<T, T> {\n  public type = 'replaceError';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public f: (err: any) => Stream<T>;\n\n  constructor(replacer: (err: any) => Stream<T>, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.f = replacer;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    try {\n      this.ins._remove(this);\n      (this.ins = this.f(err))._add(this);\n    } catch (e) {\n      u._e(e);\n    }\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass StartWith<T> implements InternalProducer<T> {\n  public type = 'startWith';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public val: T;\n\n  constructor(ins: Stream<T>, val: T) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.val = val;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.out._n(this.val);\n    this.ins._add(out);\n  }\n\n  _stop(): void {\n    this.ins._remove(this.out);\n    this.out = NO as Stream<T>;\n  }\n}\n\nclass Take<T> implements Operator<T, T> {\n  public type = 'take';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public max: number;\n  private taken: number;\n\n  constructor(max: number, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.max = max;\n    this.taken = 0;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.taken = 0;\n    if (this.max <= 0) out._c(); else this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    const m = ++this.taken;\n    if (m < this.max) u._n(t); else if (m === this.max) {\n      u._n(t);\n      u._c();\n    }\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nexport class Stream<T> implements InternalListener<T> {\n  public _prod: InternalProducer<T>;\n  protected _ils: Array<InternalListener<T>>; // 'ils' = Internal listeners\n  protected _stopID: any;\n  protected _dl: InternalListener<T>; // the debug listener\n  protected _d: boolean; // flag indicating the existence of the debug listener\n  protected _target: Stream<T>; // imitation target if this Stream will imitate\n  protected _err: any;\n\n  constructor(producer?: InternalProducer<T>) {\n    this._prod = producer || NO as InternalProducer<T>;\n    this._ils = [];\n    this._stopID = NO;\n    this._dl = NO as InternalListener<T>;\n    this._d = false;\n    this._target = NO as Stream<T>;\n    this._err = NO;\n  }\n\n  _n(t: T): void {\n    const a = this._ils;\n    const L = a.length;\n    if (this._d) this._dl._n(t);\n    if (L == 1) a[0]._n(t); else if (L == 0) return; else {\n      const b = cp(a);\n      for (let i = 0; i < L; i++) b[i]._n(t);\n    }\n  }\n\n  _e(err: any): void {\n    if (this._err !== NO) return;\n    this._err = err;\n    const a = this._ils;\n    const L = a.length;\n    this._x();\n    if (this._d) this._dl._e(err);\n    if (L == 1) a[0]._e(err); else if (L == 0) return; else {\n      const b = cp(a);\n      for (let i = 0; i < L; i++) b[i]._e(err);\n    }\n    if (!this._d && L == 0) throw this._err;\n  }\n\n  _c(): void {\n    const a = this._ils;\n    const L = a.length;\n    this._x();\n    if (this._d) this._dl._c();\n    if (L == 1) a[0]._c(); else if (L == 0) return; else {\n      const b = cp(a);\n      for (let i = 0; i < L; i++) b[i]._c();\n    }\n  }\n\n  _x(): void { // tear down logic, after error or complete\n    if (this._ils.length === 0) return;\n    if (this._prod !== NO) this._prod._stop();\n    this._err = NO;\n    this._ils = [];\n  }\n\n  _stopNow() {\n    // WARNING: code that calls this method should\n    // first check if this._prod is valid (not `NO`)\n    this._prod._stop();\n    this._err = NO;\n    this._stopID = NO;\n  }\n\n  _add(il: InternalListener<T>): void {\n    const ta = this._target;\n    if (ta !== NO) return ta._add(il);\n    const a = this._ils;\n    a.push(il);\n    if (a.length > 1) return;\n    if (this._stopID !== NO) {\n      clearTimeout(this._stopID);\n      this._stopID = NO;\n    } else {\n      const p = this._prod;\n      if (p !== NO) p._start(this);\n    }\n  }\n\n  _remove(il: InternalListener<T>): void {\n    const ta = this._target;\n    if (ta !== NO) return ta._remove(il);\n    const a = this._ils;\n    const i = a.indexOf(il);\n    if (i > -1) {\n      a.splice(i, 1);\n      if (this._prod !== NO && a.length <= 0) {\n        this._err = NO;\n        this._stopID = setTimeout(() => this._stopNow());\n      } else if (a.length === 1) {\n        this._pruneCycles();\n      }\n    }\n  }\n\n  // If all paths stemming from `this` stream eventually end at `this`\n  // stream, then we remove the single listener of `this` stream, to\n  // force it to end its execution and dispose resources. This method\n  // assumes as a precondition that this._ils has just one listener.\n  _pruneCycles() {\n    if (this._hasNoSinks(this, [])) this._remove(this._ils[0]);\n  }\n\n  // Checks whether *there is no* path starting from `x` that leads to an end\n  // listener (sink) in the stream graph, following edges A->B where B is a\n  // listener of A. This means these paths constitute a cycle somehow. Is given\n  // a trace of all visited nodes so far.\n  _hasNoSinks(x: InternalListener<any>, trace: Array<any>): boolean {\n    if (trace.indexOf(x) !== -1)\n      return true; else\n    if ((x as any as OutSender<any>).out === this)\n      return true; else\n    if ((x as any as OutSender<any>).out && (x as any as OutSender<any>).out !== NO)\n      return this._hasNoSinks((x as any as OutSender<any>).out, trace.concat(x)); else\n    if ((x as Stream<any>)._ils) {\n      for (let i = 0, N = (x as Stream<any>)._ils.length; i < N; i++)\n        if (!this._hasNoSinks((x as Stream<any>)._ils[i], trace.concat(x)))\n          return false;\n      return true;\n    } else return false;\n  }\n\n  private ctor(): typeof Stream {\n    return this instanceof MemoryStream ? MemoryStream : Stream;\n  }\n\n  /**\n   * Adds a Listener to the Stream.\n   *\n   * @param {Listener} listener\n   */\n  addListener(listener: Partial<Listener<T>>): void {\n    (listener as InternalListener<T>)._n = listener.next || noop;\n    (listener as InternalListener<T>)._e = listener.error || noop;\n    (listener as InternalListener<T>)._c = listener.complete || noop;\n    this._add(listener as InternalListener<T>);\n  }\n\n  /**\n   * Removes a Listener from the Stream, assuming the Listener was added to it.\n   *\n   * @param {Listener<T>} listener\n   */\n  removeListener(listener: Partial<Listener<T>>): void {\n    this._remove(listener as InternalListener<T>);\n  }\n\n  /**\n   * Adds a Listener to the Stream returning a Subscription to remove that\n   * listener.\n   *\n   * @param {Listener} listener\n   * @returns {Subscription}\n   */\n  subscribe(listener: Partial<Listener<T>>): Subscription {\n    this.addListener(listener);\n    return new StreamSub<T>(this, listener as InternalListener<T>);\n  }\n\n  /**\n   * Add interop between most.js and RxJS 5\n   *\n   * @returns {Stream}\n   */\n  [$$observable](): Stream<T> {\n    return this;\n  }\n\n  /**\n   * Creates a new Stream given a Producer.\n   *\n   * @factory true\n   * @param {Producer} producer An optional Producer that dictates how to\n   * start, generate events, and stop the Stream.\n   * @return {Stream}\n   */\n  static create<T>(producer?: Producer<T>): Stream<T> {\n    if (producer) {\n      if (typeof producer.start !== 'function'\n      || typeof producer.stop !== 'function')\n        throw new Error('producer requires both start and stop functions');\n      internalizeProducer(producer); // mutates the input\n    }\n    return new Stream(producer as InternalProducer<T> & Producer<T>);\n  }\n\n  /**\n   * Creates a new MemoryStream given a Producer.\n   *\n   * @factory true\n   * @param {Producer} producer An optional Producer that dictates how to\n   * start, generate events, and stop the Stream.\n   * @return {MemoryStream}\n   */\n  static createWithMemory<T>(producer?: Producer<T>): MemoryStream<T> {\n    if (producer) internalizeProducer(producer); // mutates the input\n    return new MemoryStream<T>(producer as InternalProducer<T> & Producer<T>);\n  }\n\n  /**\n   * Creates a Stream that does nothing when started. It never emits any event.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   *          never\n   * -----------------------\n   * ```\n   *\n   * @factory true\n   * @return {Stream}\n   */\n  static never(): Stream<any> {\n    return new Stream<any>({_start: noop, _stop: noop});\n  }\n\n  /**\n   * Creates a Stream that immediately emits the \"complete\" notification when\n   * started, and that's it.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * empty\n   * -|\n   * ```\n   *\n   * @factory true\n   * @return {Stream}\n   */\n  static empty(): Stream<any> {\n    return new Stream<any>({\n      _start(il: InternalListener<any>) { il._c(); },\n      _stop: noop,\n    });\n  }\n\n  /**\n   * Creates a Stream that immediately emits an \"error\" notification with the\n   * value you passed as the `error` argument when the stream starts, and that's\n   * it.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * throw(X)\n   * -X\n   * ```\n   *\n   * @factory true\n   * @param error The error event to emit on the created stream.\n   * @return {Stream}\n   */\n  static throw(error: any): Stream<any> {\n    return new Stream<any>({\n      _start(il: InternalListener<any>) { il._e(error); },\n      _stop: noop,\n    });\n  }\n\n  /**\n   * Creates a stream from an Array, Promise, or an Observable.\n   *\n   * @factory true\n   * @param {Array|PromiseLike|Observable} input The input to make a stream from.\n   * @return {Stream}\n   */\n  static from<T>(input: PromiseLike<T> | Stream<T> | Array<T> | Observable<T>): Stream<T> {\n    if (typeof input[$$observable] === 'function')\n      return Stream.fromObservable<T>(input as Observable<T>); else\n    if (typeof (input as PromiseLike<T>).then === 'function')\n      return Stream.fromPromise<T>(input as PromiseLike<T>); else\n    if (Array.isArray(input))\n      return Stream.fromArray<T>(input);\n\n    throw new TypeError(`Type of input to from() must be an Array, Promise, or Observable`);\n  }\n\n  /**\n   * Creates a Stream that immediately emits the arguments that you give to\n   * *of*, then completes.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * of(1,2,3)\n   * 123|\n   * ```\n   *\n   * @factory true\n   * @param a The first value you want to emit as an event on the stream.\n   * @param b The second value you want to emit as an event on the stream. One\n   * or more of these values may be given as arguments.\n   * @return {Stream}\n   */\n  static of<T>(...items: Array<T>): Stream<T> {\n    return Stream.fromArray<T>(items);\n  }\n\n  /**\n   * Converts an array to a stream. The returned stream will emit synchronously\n   * all the items in the array, and then complete.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * fromArray([1,2,3])\n   * 123|\n   * ```\n   *\n   * @factory true\n   * @param {Array} array The array to be converted as a stream.\n   * @return {Stream}\n   */\n  static fromArray<T>(array: Array<T>): Stream<T> {\n    return new Stream<T>(new FromArray<T>(array));\n  }\n\n  /**\n   * Converts a promise to a stream. The returned stream will emit the resolved\n   * value of the promise, and then complete. However, if the promise is\n   * rejected, the stream will emit the corresponding error.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * fromPromise( ----42 )\n   * -----------------42|\n   * ```\n   *\n   * @factory true\n   * @param {PromiseLike} promise The promise to be converted as a stream.\n   * @return {Stream}\n   */\n  static fromPromise<T>(promise: PromiseLike<T>): Stream<T> {\n    return new Stream<T>(new FromPromise<T>(promise));\n  }\n\n  /**\n   * Converts an Observable into a Stream.\n   *\n   * @factory true\n   * @param {any} observable The observable to be converted as a stream.\n   * @return {Stream}\n   */\n  static fromObservable<T>(obs: {subscribe: any}): Stream<T> {\n    if ((obs as Stream<T>).endWhen) return obs as Stream<T>;\n    const o = typeof obs[$$observable] === 'function' ? obs[$$observable]() : obs;\n    return new Stream<T>(new FromObservable(o));\n  }\n\n  /**\n   * Creates a stream that periodically emits incremental numbers, every\n   * `period` milliseconds.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   *     periodic(1000)\n   * ---0---1---2---3---4---...\n   * ```\n   *\n   * @factory true\n   * @param {number} period The interval in milliseconds to use as a rate of\n   * emission.\n   * @return {Stream}\n   */\n  static periodic(period: number): Stream<number> {\n    return new Stream<number>(new Periodic(period));\n  }\n\n  /**\n   * Blends multiple streams together, emitting events from all of them\n   * concurrently.\n   *\n   * *merge* takes multiple streams as arguments, and creates a stream that\n   * behaves like each of the argument streams, in parallel.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1----2-----3--------4---\n   * ----a-----b----c---d------\n   *            merge\n   * --1-a--2--b--3-c---d--4---\n   * ```\n   *\n   * @factory true\n   * @param {Stream} stream1 A stream to merge together with other streams.\n   * @param {Stream} stream2 A stream to merge together with other streams. Two\n   * or more streams may be given as arguments.\n   * @return {Stream}\n   */\n  static merge: MergeSignature = function merge(...streams: Array<Stream<any>>) {\n    return new Stream<any>(new Merge(streams));\n  } as MergeSignature;\n\n  /**\n   * Combines multiple input streams together to return a stream whose events\n   * are arrays that collect the latest events from each input stream.\n   *\n   * *combine* internally remembers the most recent event from each of the input\n   * streams. When any of the input streams emits an event, that event together\n   * with all the other saved events are combined into an array. That array will\n   * be emitted on the output stream. It's essentially a way of joining together\n   * the events from multiple streams.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1----2-----3--------4---\n   * ----a-----b-----c--d------\n   *          combine\n   * ----1a-2a-2b-3b-3c-3d-4d--\n   * ```\n   *\n   * @factory true\n   * @param {Stream} stream1 A stream to combine together with other streams.\n   * @param {Stream} stream2 A stream to combine together with other streams.\n   * Multiple streams, not just two, may be given as arguments.\n   * @return {Stream}\n   */\n  static combine: CombineSignature = function combine(...streams: Array<Stream<any>>) {\n    return new Stream<Array<any>>(new Combine<any>(streams));\n  } as CombineSignature;\n\n  protected _map<U>(project: (t: T) => U): Stream<U> | MemoryStream<U> {\n    return new (this.ctor())<U>(new MapOp<T, U>(project, this));\n  }\n\n  /**\n   * Transforms each event from the input Stream through a `project` function,\n   * to get a Stream that emits those transformed events.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---3--5-----7------\n   *    map(i => i * 10)\n   * --10--30-50----70-----\n   * ```\n   *\n   * @param {Function} project A function of type `(t: T) => U` that takes event\n   * `t` of type `T` from the input Stream and produces an event of type `U`, to\n   * be emitted on the output Stream.\n   * @return {Stream}\n   */\n  map<U>(project: (t: T) => U): Stream<U> {\n    return this._map(project);\n  }\n\n  /**\n   * It's like `map`, but transforms each input event to always the same\n   * constant value on the output Stream.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---3--5-----7-----\n   *       mapTo(10)\n   * --10--10-10----10----\n   * ```\n   *\n   * @param projectedValue A value to emit on the output Stream whenever the\n   * input Stream emits any value.\n   * @return {Stream}\n   */\n  mapTo<U>(projectedValue: U): Stream<U> {\n    const s = this.map(() => projectedValue);\n    const op: Operator<T, U> = s._prod as Operator<T, U>;\n    op.type = 'mapTo';\n    return s;\n  }\n\n  filter<S extends T>(passes: (t: T) => t is S): Stream<S>;\n  filter(passes: (t: T) => boolean): Stream<T>;\n  /**\n   * Only allows events that pass the test given by the `passes` argument.\n   *\n   * Each event from the input stream is given to the `passes` function. If the\n   * function returns `true`, the event is forwarded to the output stream,\n   * otherwise it is ignored and not forwarded.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---2--3-----4-----5---6--7-8--\n   *     filter(i => i % 2 === 0)\n   * ------2--------4---------6----8--\n   * ```\n   *\n   * @param {Function} passes A function of type `(t: T) => boolean` that takes\n   * an event from the input stream and checks if it passes, by returning a\n   * boolean.\n   * @return {Stream}\n   */\n  filter(passes: (t: T) => boolean): Stream<T> {\n    const p = this._prod;\n    if (p instanceof Filter)\n      return new Stream<T>(new Filter<T>(\n        and((p as Filter<T>).f, passes),\n        (p as Filter<T>).ins\n      ));\n    return new Stream<T>(new Filter<T>(passes, this));\n  }\n\n  /**\n   * Lets the first `amount` many events from the input stream pass to the\n   * output stream, then makes the output stream complete.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --a---b--c----d---e--\n   *    take(3)\n   * --a---b--c|\n   * ```\n   *\n   * @param {number} amount How many events to allow from the input stream\n   * before completing the output stream.\n   * @return {Stream}\n   */\n  take(amount: number): Stream<T> {\n    return new (this.ctor())<T>(new Take<T>(amount, this));\n  }\n\n  /**\n   * Ignores the first `amount` many events from the input stream, and then\n   * after that starts forwarding events from the input stream to the output\n   * stream.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --a---b--c----d---e--\n   *       drop(3)\n   * --------------d---e--\n   * ```\n   *\n   * @param {number} amount How many events to ignore from the input stream\n   * before forwarding all events from the input stream to the output stream.\n   * @return {Stream}\n   */\n  drop(amount: number): Stream<T> {\n    return new Stream<T>(new Drop<T>(amount, this));\n  }\n\n  /**\n   * When the input stream completes, the output stream will emit the last event\n   * emitted by the input stream, and then will also complete.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --a---b--c--d----|\n   *       last()\n   * -----------------d|\n   * ```\n   *\n   * @return {Stream}\n   */\n  last(): Stream<T> {\n    return new Stream<T>(new Last<T>(this));\n  }\n\n  /**\n   * Prepends the given `initial` value to the sequence of events emitted by the\n   * input stream. The returned stream is a MemoryStream, which means it is\n   * already `remember()`'d.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * ---1---2-----3---\n   *   startWith(0)\n   * 0--1---2-----3---\n   * ```\n   *\n   * @param initial The value or event to prepend.\n   * @return {MemoryStream}\n   */\n  startWith(initial: T): MemoryStream<T> {\n    return new MemoryStream<T>(new StartWith<T>(this, initial));\n  }\n\n  /**\n   * Uses another stream to determine when to complete the current stream.\n   *\n   * When the given `other` stream emits an event or completes, the output\n   * stream will complete. Before that happens, the output stream will behaves\n   * like the input stream.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * ---1---2-----3--4----5----6---\n   *   endWhen( --------a--b--| )\n   * ---1---2-----3--4--|\n   * ```\n   *\n   * @param other Some other stream that is used to know when should the output\n   * stream of this operator complete.\n   * @return {Stream}\n   */\n  endWhen(other: Stream<any>): Stream<T> {\n    return new (this.ctor())<T>(new EndWhen<T>(other, this));\n  }\n\n  /**\n   * \"Folds\" the stream onto itself.\n   *\n   * Combines events from the past throughout\n   * the entire execution of the input stream, allowing you to accumulate them\n   * together. It's essentially like `Array.prototype.reduce`. The returned\n   * stream is a MemoryStream, which means it is already `remember()`'d.\n   *\n   * The output stream starts by emitting the `seed` which you give as argument.\n   * Then, when an event happens on the input stream, it is combined with that\n   * seed value through the `accumulate` function, and the output value is\n   * emitted on the output stream. `fold` remembers that output value as `acc`\n   * (\"accumulator\"), and then when a new input event `t` happens, `acc` will be\n   * combined with that to produce the new `acc` and so forth.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * ------1-----1--2----1----1------\n   *   fold((acc, x) => acc + x, 3)\n   * 3-----4-----5--7----8----9------\n   * ```\n   *\n   * @param {Function} accumulate A function of type `(acc: R, t: T) => R` that\n   * takes the previous accumulated value `acc` and the incoming event from the\n   * input stream and produces the new accumulated value.\n   * @param seed The initial accumulated value, of type `R`.\n   * @return {MemoryStream}\n   */\n  fold<R>(accumulate: (acc: R, t: T) => R, seed: R): MemoryStream<R> {\n    return new MemoryStream<R>(new Fold<T, R>(accumulate, seed, this));\n  }\n\n  /**\n   * Replaces an error with another stream.\n   *\n   * When (and if) an error happens on the input stream, instead of forwarding\n   * that error to the output stream, *replaceError* will call the `replace`\n   * function which returns the stream that the output stream will replicate.\n   * And, in case that new stream also emits an error, `replace` will be called\n   * again to get another stream to start replicating.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---2-----3--4-----X\n   *   replaceError( () => --10--| )\n   * --1---2-----3--4--------10--|\n   * ```\n   *\n   * @param {Function} replace A function of type `(err) => Stream` that takes\n   * the error that occurred on the input stream or on the previous replacement\n   * stream and returns a new stream. The output stream will behave like the\n   * stream that this function returns.\n   * @return {Stream}\n   */\n  replaceError(replace: (err: any) => Stream<T>): Stream<T> {\n    return new (this.ctor())<T>(new ReplaceError<T>(replace, this));\n  }\n\n  /**\n   * Flattens a \"stream of streams\", handling only one nested stream at a time\n   * (no concurrency).\n   *\n   * If the input stream is a stream that emits streams, then this operator will\n   * return an output stream which is a flat stream: emits regular events. The\n   * flattening happens without concurrency. It works like this: when the input\n   * stream emits a nested stream, *flatten* will start imitating that nested\n   * one. However, as soon as the next nested stream is emitted on the input\n   * stream, *flatten* will forget the previous nested one it was imitating, and\n   * will start imitating the new nested one.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --+--------+---------------\n   *   \\        \\\n   *    \\       ----1----2---3--\n   *    --a--b----c----d--------\n   *           flatten\n   * -----a--b------1----2---3--\n   * ```\n   *\n   * @return {Stream}\n   */\n  flatten<R>(this: Stream<Stream<R>>): T {\n    const p = this._prod;\n    return new Stream<R>(new Flatten(this)) as T & Stream<R>;\n  }\n\n  /**\n   * Passes the input stream to a custom operator, to produce an output stream.\n   *\n   * *compose* is a handy way of using an existing function in a chained style.\n   * Instead of writing `outStream = f(inStream)` you can write\n   * `outStream = inStream.compose(f)`.\n   *\n   * @param {function} operator A function that takes a stream as input and\n   * returns a stream as well.\n   * @return {Stream}\n   */\n  compose<U>(operator: (stream: Stream<T>) => U): U {\n    return operator(this);\n  }\n\n  /**\n   * Returns an output stream that behaves like the input stream, but also\n   * remembers the most recent event that happens on the input stream, so that a\n   * newly added listener will immediately receive that memorised event.\n   *\n   * @return {MemoryStream}\n   */\n  remember(): MemoryStream<T> {\n    return new MemoryStream<T>(new Remember<T>(this));\n  }\n\n  debug(): Stream<T>;\n  debug(labelOrSpy: string): Stream<T>;\n  debug(labelOrSpy: (t: T) => any): Stream<T>;\n  /**\n   * Returns an output stream that identically behaves like the input stream,\n   * but also runs a `spy` function for each event, to help you debug your app.\n   *\n   * *debug* takes a `spy` function as argument, and runs that for each event\n   * happening on the input stream. If you don't provide the `spy` argument,\n   * then *debug* will just `console.log` each event. This helps you to\n   * understand the flow of events through some operator chain.\n   *\n   * Please note that if the output stream has no listeners, then it will not\n   * start, which means `spy` will never run because no actual event happens in\n   * that case.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1----2-----3-----4--\n   *         debug\n   * --1----2-----3-----4--\n   * ```\n   *\n   * @param {function} labelOrSpy A string to use as the label when printing\n   * debug information on the console, or a 'spy' function that takes an event\n   * as argument, and does not need to return anything.\n   * @return {Stream}\n   */\n  debug(labelOrSpy?: string | ((t: T) => any)): Stream<T> {\n    return new (this.ctor())<T>(new Debug<T>(this, labelOrSpy));\n  }\n\n  /**\n   * *imitate* changes this current Stream to emit the same events that the\n   * `other` given Stream does. This method returns nothing.\n   *\n   * This method exists to allow one thing: **circular dependency of streams**.\n   * For instance, let's imagine that for some reason you need to create a\n   * circular dependency where stream `first$` depends on stream `second$`\n   * which in turn depends on `first$`:\n   *\n   * <!-- skip-example -->\n   * ```js\n   * import delay from 'xstream/extra/delay'\n   *\n   * var first$ = second$.map(x => x * 10).take(3);\n   * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));\n   * ```\n   *\n   * However, that is invalid JavaScript, because `second$` is undefined\n   * on the first line. This is how *imitate* can help solve it:\n   *\n   * ```js\n   * import delay from 'xstream/extra/delay'\n   *\n   * var secondProxy$ = xs.create();\n   * var first$ = secondProxy$.map(x => x * 10).take(3);\n   * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));\n   * secondProxy$.imitate(second$);\n   * ```\n   *\n   * We create `secondProxy$` before the others, so it can be used in the\n   * declaration of `first$`. Then, after both `first$` and `second$` are\n   * defined, we hook `secondProxy$` with `second$` with `imitate()` to tell\n   * that they are \"the same\". `imitate` will not trigger the start of any\n   * stream, it just binds `secondProxy$` and `second$` together.\n   *\n   * The following is an example where `imitate()` is important in Cycle.js\n   * applications. A parent component contains some child components. A child\n   * has an action stream which is given to the parent to define its state:\n   *\n   * <!-- skip-example -->\n   * ```js\n   * const childActionProxy$ = xs.create();\n   * const parent = Parent({...sources, childAction$: childActionProxy$});\n   * const childAction$ = parent.state$.map(s => s.child.action$).flatten();\n   * childActionProxy$.imitate(childAction$);\n   * ```\n   *\n   * Note, though, that **`imitate()` does not support MemoryStreams**. If we\n   * would attempt to imitate a MemoryStream in a circular dependency, we would\n   * either get a race condition (where the symptom would be \"nothing happens\")\n   * or an infinite cyclic emission of values. It's useful to think about\n   * MemoryStreams as cells in a spreadsheet. It doesn't make any sense to\n   * define a spreadsheet cell `A1` with a formula that depends on `B1` and\n   * cell `B1` defined with a formula that depends on `A1`.\n   *\n   * If you find yourself wanting to use `imitate()` with a\n   * MemoryStream, you should rework your code around `imitate()` to use a\n   * Stream instead. Look for the stream in the circular dependency that\n   * represents an event stream, and that would be a candidate for creating a\n   * proxy Stream which then imitates the target Stream.\n   *\n   * @param {Stream} target The other stream to imitate on the current one. Must\n   * not be a MemoryStream.\n   */\n  imitate(target: Stream<T>): void {\n    if (target instanceof MemoryStream)\n      throw new Error('A MemoryStream was given to imitate(), but it only ' +\n      'supports a Stream. Read more about this restriction here: ' +\n      'https://github.com/staltz/xstream#faq');\n    this._target = target;\n    for (let ils = this._ils, N = ils.length, i = 0; i < N; i++) target._add(ils[i]);\n    this._ils = [];\n  }\n\n  /**\n   * Forces the Stream to emit the given value to its listeners.\n   *\n   * As the name indicates, if you use this, you are most likely doing something\n   * The Wrong Way. Please try to understand the reactive way before using this\n   * method. Use it only when you know what you are doing.\n   *\n   * @param value The \"next\" value you want to broadcast to all listeners of\n   * this Stream.\n   */\n  shamefullySendNext(value: T) {\n    this._n(value);\n  }\n\n  /**\n   * Forces the Stream to emit the given error to its listeners.\n   *\n   * As the name indicates, if you use this, you are most likely doing something\n   * The Wrong Way. Please try to understand the reactive way before using this\n   * method. Use it only when you know what you are doing.\n   *\n   * @param {any} error The error you want to broadcast to all the listeners of\n   * this Stream.\n   */\n  shamefullySendError(error: any) {\n    this._e(error);\n  }\n\n  /**\n   * Forces the Stream to emit the \"completed\" event to its listeners.\n   *\n   * As the name indicates, if you use this, you are most likely doing something\n   * The Wrong Way. Please try to understand the reactive way before using this\n   * method. Use it only when you know what you are doing.\n   */\n  shamefullySendComplete() {\n    this._c();\n  }\n\n  /**\n   * Adds a \"debug\" listener to the stream. There can only be one debug\n   * listener, that's why this is 'setDebugListener'. To remove the debug\n   * listener, just call setDebugListener(null).\n   *\n   * A debug listener is like any other listener. The only difference is that a\n   * debug listener is \"stealthy\": its presence/absence does not trigger the\n   * start/stop of the stream (or the producer inside the stream). This is\n   * useful so you can inspect what is going on without changing the behavior\n   * of the program. If you have an idle stream and you add a normal listener to\n   * it, the stream will start executing. But if you set a debug listener on an\n   * idle stream, it won't start executing (not until the first normal listener\n   * is added).\n   *\n   * As the name indicates, we don't recommend using this method to build app\n   * logic. In fact, in most cases the debug operator works just fine. Only use\n   * this one if you know what you're doing.\n   *\n   * @param {Listener<T>} listener\n   */\n  setDebugListener(listener: Partial<Listener<T>> | null | undefined) {\n    if (!listener) {\n      this._d = false;\n      this._dl = NO as InternalListener<T>;\n    } else {\n      this._d = true;\n      (listener as InternalListener<T>)._n = listener.next || noop;\n      (listener as InternalListener<T>)._e = listener.error || noop;\n      (listener as InternalListener<T>)._c = listener.complete || noop;\n      this._dl = listener as InternalListener<T>;\n    }\n  }\n}\n\nexport class MemoryStream<T> extends Stream<T> {\n  private _v: T;\n  private _has: boolean = false;\n  constructor(producer: InternalProducer<T>) {\n    super(producer);\n  }\n\n  _n(x: T) {\n    this._v = x;\n    this._has = true;\n    super._n(x);\n  }\n\n  _add(il: InternalListener<T>): void {\n    const ta = this._target;\n    if (ta !== NO) return ta._add(il);\n    const a = this._ils;\n    a.push(il);\n    if (a.length > 1) {\n      if (this._has) il._n(this._v);\n      return;\n    }\n    if (this._stopID !== NO) {\n      if (this._has) il._n(this._v);\n      clearTimeout(this._stopID);\n      this._stopID = NO;\n    } else if (this._has) il._n(this._v); else {\n      const p = this._prod;\n      if (p !== NO) p._start(this);\n    }\n  }\n\n  _stopNow() {\n    this._has = false;\n    super._stopNow();\n  }\n\n  _x(): void {\n    this._has = false;\n    super._x();\n  }\n\n  map<U>(project: (t: T) => U): MemoryStream<U> {\n    return this._map(project) as MemoryStream<U>;\n  }\n\n  mapTo<U>(projectedValue: U): MemoryStream<U> {\n    return super.mapTo(projectedValue) as MemoryStream<U>;\n  }\n\n  take(amount: number): MemoryStream<T> {\n    return super.take(amount) as MemoryStream<T>;\n  }\n\n  endWhen(other: Stream<any>): MemoryStream<T> {\n    return super.endWhen(other) as MemoryStream<T>;\n  }\n\n  replaceError(replace: (err: any) => Stream<T>): MemoryStream<T> {\n    return super.replaceError(replace) as MemoryStream<T>;\n  }\n\n  remember(): MemoryStream<T> {\n    return this;\n  }\n\n  debug(): MemoryStream<T>;\n  debug(labelOrSpy: string): MemoryStream<T>;\n  debug(labelOrSpy: (t: T) => any): MemoryStream<T>;\n  debug(labelOrSpy?: string | ((t: T) => any) | undefined): MemoryStream<T> {\n    return super.debug(labelOrSpy as any) as MemoryStream<T>;\n  }\n}\n\nexport {NO, NO_IL};\nconst xs = Stream;\ntype xs<T> = Stream<T>;\nexport default xs;\n","import {h, VNode, VNodeData} from 'snabbdom';\n\nexport interface ThunkData extends VNodeData {\n  fn(): VNode;\n  args: Array<any>;\n}\n\nexport interface Thunk extends VNode {\n  data: ThunkData;\n}\n\nfunction copyToThunk(vnode: VNode, thunkVNode: Thunk): void {\n  thunkVNode.elm = vnode.elm;\n  (vnode.data as ThunkData).fn = thunkVNode.data.fn;\n  (vnode.data as ThunkData).args = thunkVNode.data.args;\n  (vnode.data as ThunkData).isolate = thunkVNode.data.isolate;\n  thunkVNode.data = vnode.data as ThunkData;\n  thunkVNode.children = vnode.children;\n  thunkVNode.text = vnode.text;\n  thunkVNode.elm = vnode.elm;\n}\n\nfunction init(thunkVNode: Thunk): void {\n  const cur = thunkVNode.data as VNodeData;\n  const vnode = (cur.fn as any).apply(undefined, cur.args);\n  copyToThunk(vnode, thunkVNode);\n}\n\nfunction prepatch(oldVnode: Thunk, thunkVNode: Thunk): void {\n  const old = oldVnode.data as VNodeData,\n    cur = thunkVNode.data as VNodeData;\n  let i: number;\n  const oldArgs = old.args,\n    args = cur.args;\n  if (old.fn !== cur.fn || (oldArgs as any).length !== (args as any).length) {\n    copyToThunk((cur.fn as any).apply(undefined, args), thunkVNode);\n  }\n  for (i = 0; i < (args as any).length; ++i) {\n    if ((oldArgs as any)[i] !== (args as any)[i]) {\n      copyToThunk((cur.fn as any).apply(undefined, args), thunkVNode);\n      return;\n    }\n  }\n  copyToThunk(oldVnode, thunkVNode);\n}\n\nexport function thunk(sel: string, fn: Function, args: Array<any>): Thunk;\nexport function thunk(\n  sel: string,\n  key: any,\n  fn: Function,\n  args: Array<any>\n): Thunk;\nexport function thunk(sel: string, key?: any, fn?: any, args?: any): VNode {\n  if (args === undefined) {\n    args = fn;\n    fn = key;\n    key = undefined;\n  }\n  return h(sel, {\n    key: key,\n    hook: {init: init, prepatch: prepatch},\n    fn: fn,\n    args: args,\n  } as VNodeData);\n}\n\nexport default thunk;\n","import {Stream} from 'xstream';\n\ndeclare var window: any;\n\nfunction getGlobal(this: any): any {\n  let globalObj: any;\n  if (typeof window !== 'undefined') {\n    globalObj = window;\n  } else if (typeof global !== 'undefined') {\n    globalObj = global;\n  } else {\n    globalObj = this;\n  }\n  globalObj.Cyclejs = globalObj.Cyclejs || {};\n  globalObj = globalObj.Cyclejs;\n  globalObj.adaptStream = globalObj.adaptStream || ((x => x) as AdaptStream);\n  return globalObj;\n}\n\nexport interface AdaptStream {\n  (s: Stream<any>): any;\n}\n\nexport function setAdapt(f: AdaptStream): void {\n  getGlobal().adaptStream = f;\n}\n\nexport function adapt(stream: Stream<any>): any {\n  return getGlobal().adaptStream(stream);\n}\n","export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n","/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n","import $$observable from 'symbol-observable';\n\nconst NO = {};\nfunction noop() {}\n\nfunction cp<T>(a: Array<T>): Array<T> {\n  const l = a.length;\n  const b = Array(l);\n  for (let i = 0; i < l; ++i) b[i] = a[i];\n  return b;\n}\n\nfunction and<T>(f1: (t: T) => boolean, f2: (t: T) => boolean): (t: T) => boolean {\n  return function andFn(t: T): boolean {\n    return f1(t) && f2(t);\n  };\n}\n\ninterface FContainer<T, R> {\n  f(t: T): R;\n}\n\nfunction _try<T, R>(c: FContainer<T, R>, t: T, u: Stream<any>): R | {} {\n  try {\n    return c.f(t);\n  } catch (e) {\n    u._e(e);\n    return NO;\n  }\n}\n\nexport interface InternalListener<T> {\n  _n: (v: T) => void;\n  _e: (err: any) => void;\n  _c: () => void;\n}\n\nconst NO_IL: InternalListener<any> = {\n  _n: noop,\n  _e: noop,\n  _c: noop,\n};\n\nexport interface InternalProducer<T> {\n  _start(listener: InternalListener<T>): void;\n  _stop: () => void;\n}\n\nexport interface OutSender<T> {\n  out: Stream<T>;\n}\n\nexport interface Operator<T, R> extends InternalProducer<R>, InternalListener<T>, OutSender<R> {\n  type: string;\n  ins: Stream<T>;\n  _start(out: Stream<R>): void;\n}\n\nexport interface Aggregator<T, U> extends InternalProducer<U>, OutSender<U> {\n  type: string;\n  insArr: Array<Stream<T>>;\n  _start(out: Stream<U>): void;\n}\n\nexport interface Producer<T> {\n  start: (listener: Listener<T>) => void;\n  stop: () => void;\n}\n\nexport interface Listener<T> {\n  next: (x: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\nexport interface Subscription {\n  unsubscribe(): void;\n}\n\nexport interface Observable<T> {\n  subscribe(listener: Listener<T>): Subscription;\n}\n\n// mutates the input\nfunction internalizeProducer<T>(producer: Producer<T> & Partial<InternalProducer<T>>) {\n  producer._start = function _start(il: InternalListener<T> & Partial<Listener<T>>) {\n    il.next = il._n;\n    il.error = il._e;\n    il.complete = il._c;\n    this.start(il);\n  };\n  producer._stop = producer.stop;\n}\n\nclass StreamSub<T> implements Subscription {\n  constructor(private _stream: Stream<T>, private _listener: InternalListener<T>) {}\n\n  unsubscribe(): void {\n    this._stream._remove(this._listener);\n  }\n}\n\nclass Observer<T> implements Listener<T> {\n  constructor(private _listener: InternalListener<T>) {}\n\n  next(value: T) {\n    this._listener._n(value);\n  }\n\n  error(err: any) {\n    this._listener._e(err);\n  }\n\n  complete() {\n    this._listener._c();\n  }\n}\n\nclass FromObservable<T> implements InternalProducer<T> {\n  public type = 'fromObservable';\n  public ins: Observable<T>;\n  public out: Stream<T>;\n  private active: boolean;\n  private _sub: Subscription | undefined;\n\n  constructor(observable: Observable<T>) {\n    this.ins = observable;\n    this.active = false;\n  }\n\n  _start(out: Stream<T>) {\n    this.out = out;\n    this.active = true;\n    this._sub = this.ins.subscribe(new Observer(out));\n    if (!this.active) this._sub.unsubscribe();\n  }\n\n  _stop() {\n    if (this._sub) this._sub.unsubscribe();\n    this.active = false;\n  }\n}\n\nexport interface MergeSignature {\n  (): Stream<any>;\n  <T1>(s1: Stream<T1>): Stream<T1>;\n  <T1, T2>(\n    s1: Stream<T1>,\n    s2: Stream<T2>): Stream<T1 | T2>;\n  <T1, T2, T3>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>): Stream<T1 | T2 | T3>;\n  <T1, T2, T3, T4>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>): Stream<T1 | T2 | T3 | T4>;\n  <T1, T2, T3, T4, T5>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>): Stream<T1 | T2 | T3 | T4 | T5>;\n  <T1, T2, T3, T4, T5, T6>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>): Stream<T1 | T2 | T3 | T4 | T5 | T6>;\n  <T1, T2, T3, T4, T5, T6, T7>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>): Stream<T1 | T2 | T3 | T4 | T5 | T6 | T7>;\n  <T1, T2, T3, T4, T5, T6, T7, T8>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>): Stream<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\n  <T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>,\n    s9: Stream<T9>): Stream<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\n  <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>,\n    s9: Stream<T9>,\n    s10: Stream<T10>): Stream<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10>;\n  <T>(...stream: Array<Stream<T>>): Stream<T>;\n}\n\nclass Merge<T> implements Aggregator<T, T>, InternalListener<T> {\n  public type = 'merge';\n  public insArr: Array<Stream<T>>;\n  public out: Stream<T>;\n  private ac: number; // ac is activeCount\n\n  constructor(insArr: Array<Stream<T>>) {\n    this.insArr = insArr;\n    this.out = NO as Stream<T>;\n    this.ac = 0;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    const s = this.insArr;\n    const L = s.length;\n    this.ac = L;\n    for (let i = 0; i < L; i++) s[i]._add(this);\n  }\n\n  _stop(): void {\n    const s = this.insArr;\n    const L = s.length;\n    for (let i = 0; i < L; i++) s[i]._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    if (--this.ac <= 0) {\n      const u = this.out;\n      if (u === NO) return;\n      u._c();\n    }\n  }\n}\n\nexport interface CombineSignature {\n  (): Stream<Array<any>>;\n  <T1>(s1: Stream<T1>): Stream<[T1]>;\n  <T1, T2>(\n    s1: Stream<T1>,\n    s2: Stream<T2>): Stream<[T1, T2]>;\n  <T1, T2, T3>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>): Stream<[T1, T2, T3]>;\n  <T1, T2, T3, T4>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>): Stream<[T1, T2, T3, T4]>;\n  <T1, T2, T3, T4, T5>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>): Stream<[T1, T2, T3, T4, T5]>;\n  <T1, T2, T3, T4, T5, T6>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>): Stream<[T1, T2, T3, T4, T5, T6]>;\n  <T1, T2, T3, T4, T5, T6, T7>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>): Stream<[T1, T2, T3, T4, T5, T6, T7]>;\n  <T1, T2, T3, T4, T5, T6, T7, T8>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>): Stream<[T1, T2, T3, T4, T5, T6, T7, T8]>;\n  <T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>,\n    s9: Stream<T9>): Stream<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;\n  <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>,\n    s9: Stream<T9>,\n    s10: Stream<T10>): Stream<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;\n  (...stream: Array<Stream<any>>): Stream<Array<any>>;\n}\n\nclass CombineListener<T> implements InternalListener<T>, OutSender<Array<T>> {\n  private i: number;\n  public out: Stream<Array<T>>;\n  private p: Combine<T>;\n\n  constructor(i: number, out: Stream<Array<T>>, p: Combine<T>) {\n    this.i = i;\n    this.out = out;\n    this.p = p;\n    p.ils.push(this);\n  }\n\n  _n(t: T): void {\n    const p = this.p, out = this.out;\n    if (out === NO) return;\n    if (p.up(t, this.i)) {\n      const a = p.vals;\n      const l = a.length;\n      const b = Array(l);\n      for (let i = 0; i < l; ++i) b[i] = a[i];\n      out._n(b);\n    }\n  }\n\n  _e(err: any): void {\n    const out = this.out;\n    if (out === NO) return;\n    out._e(err);\n  }\n\n  _c(): void {\n    const p = this.p;\n    if (p.out === NO) return;\n    if (--p.Nc === 0) p.out._c();\n  }\n}\n\nclass Combine<R> implements Aggregator<any, Array<R>> {\n  public type = 'combine';\n  public insArr: Array<Stream<any>>;\n  public out: Stream<Array<R>>;\n  public ils: Array<CombineListener<any>>;\n  public Nc: number; // *N*umber of streams still to send *c*omplete\n  public Nn: number; // *N*umber of streams still to send *n*ext\n  public vals: Array<R>;\n\n  constructor(insArr: Array<Stream<any>>) {\n    this.insArr = insArr;\n    this.out = NO as Stream<Array<R>>;\n    this.ils = [];\n    this.Nc = this.Nn = 0;\n    this.vals = [];\n  }\n\n  up(t: any, i: number): boolean {\n    const v = this.vals[i];\n    const Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;\n    this.vals[i] = t;\n    return Nn === 0;\n  }\n\n  _start(out: Stream<Array<R>>): void {\n    this.out = out;\n    const s = this.insArr;\n    const n = this.Nc = this.Nn = s.length;\n    const vals = this.vals = new Array(n);\n    if (n === 0) {\n      out._n([]);\n      out._c();\n    } else {\n      for (let i = 0; i < n; i++) {\n        vals[i] = NO;\n        s[i]._add(new CombineListener(i, out, this));\n      }\n    }\n  }\n\n  _stop(): void {\n    const s = this.insArr;\n    const n = s.length;\n    const ils = this.ils;\n    for (let i = 0; i < n; i++) s[i]._remove(ils[i]);\n    this.out = NO as Stream<Array<R>>;\n    this.ils = [];\n    this.vals = [];\n  }\n}\n\nclass FromArray<T> implements InternalProducer<T> {\n  public type = 'fromArray';\n  public a: Array<T>;\n\n  constructor(a: Array<T>) {\n    this.a = a;\n  }\n\n  _start(out: InternalListener<T>): void {\n    const a = this.a;\n    for (let i = 0, n = a.length; i < n; i++) out._n(a[i]);\n    out._c();\n  }\n\n  _stop(): void {\n  }\n}\n\nclass FromPromise<T> implements InternalProducer<T> {\n  public type = 'fromPromise';\n  public on: boolean;\n  public p: PromiseLike<T>;\n\n  constructor(p: PromiseLike<T>) {\n    this.on = false;\n    this.p = p;\n  }\n\n  _start(out: InternalListener<T>): void {\n    const prod = this;\n    this.on = true;\n    this.p.then(\n      (v: T) => {\n        if (prod.on) {\n          out._n(v);\n          out._c();\n        }\n      },\n      (e: any) => {\n        out._e(e);\n      },\n    ).then(noop, (err: any) => {\n      setTimeout(() => { throw err; });\n    });\n  }\n\n  _stop(): void {\n    this.on = false;\n  }\n}\n\nclass Periodic implements InternalProducer<number> {\n  public type = 'periodic';\n  public period: number;\n  private intervalID: any;\n  private i: number;\n\n  constructor(period: number) {\n    this.period = period;\n    this.intervalID = -1;\n    this.i = 0;\n  }\n\n  _start(out: InternalListener<number>): void {\n    const self = this;\n    function intervalHandler() { out._n(self.i++); }\n    this.intervalID = setInterval(intervalHandler, this.period);\n  }\n\n  _stop(): void {\n    if (this.intervalID !== -1) clearInterval(this.intervalID);\n    this.intervalID = -1;\n    this.i = 0;\n  }\n}\n\nclass Debug<T> implements Operator<T, T> {\n  public type = 'debug';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  private s: (t: T) => any; // spy\n  private l: string; // label\n\n  constructor(ins: Stream<T>);\n  constructor(ins: Stream<T>, arg?: string);\n  constructor(ins: Stream<T>, arg?: (t: T) => any);\n  constructor(ins: Stream<T>, arg?: string | ((t: T) => any));\n  constructor(ins: Stream<T>, arg?: string | ((t: T) => any) | undefined) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.s = noop;\n    this.l = '';\n    if (typeof arg === 'string') this.l = arg; else if (typeof arg === 'function') this.s = arg;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    const s = this.s, l = this.l;\n    if (s !== noop) {\n      try {\n        s(t);\n      } catch (e) {\n        u._e(e);\n      }\n    } else if (l) console.log(l + ':', t); else console.log(t);\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass Drop<T> implements Operator<T, T> {\n  public type = 'drop';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public max: number;\n  private dropped: number;\n\n  constructor(max: number, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.max = max;\n    this.dropped = 0;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.dropped = 0;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    if (this.dropped++ >= this.max) u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass EndWhenListener<T> implements InternalListener<any> {\n  private out: Stream<T>;\n  private op: EndWhen<T>;\n\n  constructor(out: Stream<T>, op: EndWhen<T>) {\n    this.out = out;\n    this.op = op;\n  }\n\n  _n() {\n    this.op.end();\n  }\n\n  _e(err: any) {\n    this.out._e(err);\n  }\n\n  _c() {\n    this.op.end();\n  }\n}\n\nclass EndWhen<T> implements Operator<T, T> {\n  public type = 'endWhen';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public o: Stream<any>; // o = other\n  private oil: InternalListener<any>; // oil = other InternalListener\n\n  constructor(o: Stream<any>, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.o = o;\n    this.oil = NO_IL;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.o._add(this.oil = new EndWhenListener(out, this));\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.o._remove(this.oil);\n    this.out = NO as Stream<T>;\n    this.oil = NO_IL;\n  }\n\n  end(): void {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    this.end();\n  }\n}\n\nclass Filter<T> implements Operator<T, T> {\n  public type = 'filter';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public f: (t: T) => boolean;\n\n  constructor(passes: (t: T) => boolean, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.f = passes;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    const r = _try(this, t, u);\n    if (r === NO || !r) return;\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass FlattenListener<T> implements InternalListener<T> {\n  private out: Stream<T>;\n  private op: Flatten<T>;\n\n  constructor(out: Stream<T>, op: Flatten<T>) {\n    this.out = out;\n    this.op = op;\n  }\n\n  _n(t: T) {\n    this.out._n(t);\n  }\n\n  _e(err: any) {\n    this.out._e(err);\n  }\n\n  _c() {\n    this.op.inner = NO as Stream<T>;\n    this.op.less();\n  }\n}\n\nclass Flatten<T> implements Operator<Stream<T>, T> {\n  public type = 'flatten';\n  public ins: Stream<Stream<T>>;\n  public out: Stream<T>;\n  private open: boolean;\n  public inner: Stream<T>; // Current inner Stream\n  private il: InternalListener<T>; // Current inner InternalListener\n\n  constructor(ins: Stream<Stream<T>>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.open = true;\n    this.inner = NO as Stream<T>;\n    this.il = NO_IL;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.open = true;\n    this.inner = NO as Stream<T>;\n    this.il = NO_IL;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    if (this.inner !== NO) this.inner._remove(this.il);\n    this.out = NO as Stream<T>;\n    this.open = true;\n    this.inner = NO as Stream<T>;\n    this.il = NO_IL;\n  }\n\n  less(): void {\n    const u = this.out;\n    if (u === NO) return;\n    if (!this.open && this.inner === NO) u._c();\n  }\n\n  _n(s: Stream<T>) {\n    const u = this.out;\n    if (u === NO) return;\n    const {inner, il} = this;\n    if (inner !== NO && il !== NO_IL) inner._remove(il);\n    (this.inner = s)._add(this.il = new FlattenListener(u, this));\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    this.open = false;\n    this.less();\n  }\n}\n\nclass Fold<T, R> implements Operator<T, R> {\n  public type = 'fold';\n  public ins: Stream<T>;\n  public out: Stream<R>;\n  public f: (t: T) => R;\n  public seed: R;\n  private acc: R; // initialized as seed\n\n  constructor(f: (acc: R, t: T) => R, seed: R, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<R>;\n    this.f = (t: T) => f(this.acc, t);\n    this.acc = this.seed = seed;\n  }\n\n  _start(out: Stream<R>): void {\n    this.out = out;\n    this.acc = this.seed;\n    out._n(this.acc);\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<R>;\n    this.acc = this.seed;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    const r = _try(this, t, u);\n    if (r === NO) return;\n    u._n(this.acc = r as R);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass Last<T> implements Operator<T, T> {\n  public type = 'last';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  private has: boolean;\n  private val: T;\n\n  constructor(ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.has = false;\n    this.val = NO as T;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.has = false;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n    this.val = NO as T;\n  }\n\n  _n(t: T) {\n    this.has = true;\n    this.val = t;\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    if (this.has) {\n      u._n(this.val);\n      u._c();\n    } else u._e(new Error('last() failed because input stream completed'));\n  }\n}\n\nclass MapOp<T, R> implements Operator<T, R> {\n  public type = 'map';\n  public ins: Stream<T>;\n  public out: Stream<R>;\n  public f: (t: T) => R;\n\n  constructor(project: (t: T) => R, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<R>;\n    this.f = project;\n  }\n\n  _start(out: Stream<R>): void {\n    this.out = out;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<R>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    const r = _try(this, t, u);\n    if (r === NO) return;\n    u._n(r as R);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass Remember<T> implements InternalProducer<T> {\n  public type = 'remember';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n\n  constructor(ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.ins._add(out);\n  }\n\n  _stop(): void {\n    this.ins._remove(this.out);\n    this.out = NO as Stream<T>;\n  }\n}\n\nclass ReplaceError<T> implements Operator<T, T> {\n  public type = 'replaceError';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public f: (err: any) => Stream<T>;\n\n  constructor(replacer: (err: any) => Stream<T>, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.f = replacer;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    try {\n      this.ins._remove(this);\n      (this.ins = this.f(err))._add(this);\n    } catch (e) {\n      u._e(e);\n    }\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nclass StartWith<T> implements InternalProducer<T> {\n  public type = 'startWith';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public val: T;\n\n  constructor(ins: Stream<T>, val: T) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.val = val;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.out._n(this.val);\n    this.ins._add(out);\n  }\n\n  _stop(): void {\n    this.ins._remove(this.out);\n    this.out = NO as Stream<T>;\n  }\n}\n\nclass Take<T> implements Operator<T, T> {\n  public type = 'take';\n  public ins: Stream<T>;\n  public out: Stream<T>;\n  public max: number;\n  private taken: number;\n\n  constructor(max: number, ins: Stream<T>) {\n    this.ins = ins;\n    this.out = NO as Stream<T>;\n    this.max = max;\n    this.taken = 0;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.taken = 0;\n    if (this.max <= 0) out._c(); else this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = NO as Stream<T>;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (u === NO) return;\n    const m = ++this.taken;\n    if (m < this.max) u._n(t); else if (m === this.max) {\n      u._n(t);\n      u._c();\n    }\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (u === NO) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (u === NO) return;\n    u._c();\n  }\n}\n\nexport class Stream<T> implements InternalListener<T> {\n  public _prod: InternalProducer<T>;\n  protected _ils: Array<InternalListener<T>>; // 'ils' = Internal listeners\n  protected _stopID: any;\n  protected _dl: InternalListener<T>; // the debug listener\n  protected _d: boolean; // flag indicating the existence of the debug listener\n  protected _target: Stream<T>; // imitation target if this Stream will imitate\n  protected _err: any;\n\n  constructor(producer?: InternalProducer<T>) {\n    this._prod = producer || NO as InternalProducer<T>;\n    this._ils = [];\n    this._stopID = NO;\n    this._dl = NO as InternalListener<T>;\n    this._d = false;\n    this._target = NO as Stream<T>;\n    this._err = NO;\n  }\n\n  _n(t: T): void {\n    const a = this._ils;\n    const L = a.length;\n    if (this._d) this._dl._n(t);\n    if (L == 1) a[0]._n(t); else if (L == 0) return; else {\n      const b = cp(a);\n      for (let i = 0; i < L; i++) b[i]._n(t);\n    }\n  }\n\n  _e(err: any): void {\n    if (this._err !== NO) return;\n    this._err = err;\n    const a = this._ils;\n    const L = a.length;\n    this._x();\n    if (this._d) this._dl._e(err);\n    if (L == 1) a[0]._e(err); else if (L == 0) return; else {\n      const b = cp(a);\n      for (let i = 0; i < L; i++) b[i]._e(err);\n    }\n    if (!this._d && L == 0) throw this._err;\n  }\n\n  _c(): void {\n    const a = this._ils;\n    const L = a.length;\n    this._x();\n    if (this._d) this._dl._c();\n    if (L == 1) a[0]._c(); else if (L == 0) return; else {\n      const b = cp(a);\n      for (let i = 0; i < L; i++) b[i]._c();\n    }\n  }\n\n  _x(): void { // tear down logic, after error or complete\n    if (this._ils.length === 0) return;\n    if (this._prod !== NO) this._prod._stop();\n    this._err = NO;\n    this._ils = [];\n  }\n\n  _stopNow() {\n    // WARNING: code that calls this method should\n    // first check if this._prod is valid (not `NO`)\n    this._prod._stop();\n    this._err = NO;\n    this._stopID = NO;\n  }\n\n  _add(il: InternalListener<T>): void {\n    const ta = this._target;\n    if (ta !== NO) return ta._add(il);\n    const a = this._ils;\n    a.push(il);\n    if (a.length > 1) return;\n    if (this._stopID !== NO) {\n      clearTimeout(this._stopID);\n      this._stopID = NO;\n    } else {\n      const p = this._prod;\n      if (p !== NO) p._start(this);\n    }\n  }\n\n  _remove(il: InternalListener<T>): void {\n    const ta = this._target;\n    if (ta !== NO) return ta._remove(il);\n    const a = this._ils;\n    const i = a.indexOf(il);\n    if (i > -1) {\n      a.splice(i, 1);\n      if (this._prod !== NO && a.length <= 0) {\n        this._err = NO;\n        this._stopID = setTimeout(() => this._stopNow());\n      } else if (a.length === 1) {\n        this._pruneCycles();\n      }\n    }\n  }\n\n  // If all paths stemming from `this` stream eventually end at `this`\n  // stream, then we remove the single listener of `this` stream, to\n  // force it to end its execution and dispose resources. This method\n  // assumes as a precondition that this._ils has just one listener.\n  _pruneCycles() {\n    if (this._hasNoSinks(this, [])) this._remove(this._ils[0]);\n  }\n\n  // Checks whether *there is no* path starting from `x` that leads to an end\n  // listener (sink) in the stream graph, following edges A->B where B is a\n  // listener of A. This means these paths constitute a cycle somehow. Is given\n  // a trace of all visited nodes so far.\n  _hasNoSinks(x: InternalListener<any>, trace: Array<any>): boolean {\n    if (trace.indexOf(x) !== -1)\n      return true; else\n    if ((x as any as OutSender<any>).out === this)\n      return true; else\n    if ((x as any as OutSender<any>).out && (x as any as OutSender<any>).out !== NO)\n      return this._hasNoSinks((x as any as OutSender<any>).out, trace.concat(x)); else\n    if ((x as Stream<any>)._ils) {\n      for (let i = 0, N = (x as Stream<any>)._ils.length; i < N; i++)\n        if (!this._hasNoSinks((x as Stream<any>)._ils[i], trace.concat(x)))\n          return false;\n      return true;\n    } else return false;\n  }\n\n  private ctor(): typeof Stream {\n    return this instanceof MemoryStream ? MemoryStream : Stream;\n  }\n\n  /**\n   * Adds a Listener to the Stream.\n   *\n   * @param {Listener} listener\n   */\n  addListener(listener: Partial<Listener<T>>): void {\n    (listener as InternalListener<T>)._n = listener.next || noop;\n    (listener as InternalListener<T>)._e = listener.error || noop;\n    (listener as InternalListener<T>)._c = listener.complete || noop;\n    this._add(listener as InternalListener<T>);\n  }\n\n  /**\n   * Removes a Listener from the Stream, assuming the Listener was added to it.\n   *\n   * @param {Listener<T>} listener\n   */\n  removeListener(listener: Partial<Listener<T>>): void {\n    this._remove(listener as InternalListener<T>);\n  }\n\n  /**\n   * Adds a Listener to the Stream returning a Subscription to remove that\n   * listener.\n   *\n   * @param {Listener} listener\n   * @returns {Subscription}\n   */\n  subscribe(listener: Partial<Listener<T>>): Subscription {\n    this.addListener(listener);\n    return new StreamSub<T>(this, listener as InternalListener<T>);\n  }\n\n  /**\n   * Add interop between most.js and RxJS 5\n   *\n   * @returns {Stream}\n   */\n  [$$observable](): Stream<T> {\n    return this;\n  }\n\n  /**\n   * Creates a new Stream given a Producer.\n   *\n   * @factory true\n   * @param {Producer} producer An optional Producer that dictates how to\n   * start, generate events, and stop the Stream.\n   * @return {Stream}\n   */\n  static create<T>(producer?: Producer<T>): Stream<T> {\n    if (producer) {\n      if (typeof producer.start !== 'function'\n      || typeof producer.stop !== 'function')\n        throw new Error('producer requires both start and stop functions');\n      internalizeProducer(producer); // mutates the input\n    }\n    return new Stream(producer as InternalProducer<T> & Producer<T>);\n  }\n\n  /**\n   * Creates a new MemoryStream given a Producer.\n   *\n   * @factory true\n   * @param {Producer} producer An optional Producer that dictates how to\n   * start, generate events, and stop the Stream.\n   * @return {MemoryStream}\n   */\n  static createWithMemory<T>(producer?: Producer<T>): MemoryStream<T> {\n    if (producer) internalizeProducer(producer); // mutates the input\n    return new MemoryStream<T>(producer as InternalProducer<T> & Producer<T>);\n  }\n\n  /**\n   * Creates a Stream that does nothing when started. It never emits any event.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   *          never\n   * -----------------------\n   * ```\n   *\n   * @factory true\n   * @return {Stream}\n   */\n  static never(): Stream<any> {\n    return new Stream<any>({_start: noop, _stop: noop});\n  }\n\n  /**\n   * Creates a Stream that immediately emits the \"complete\" notification when\n   * started, and that's it.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * empty\n   * -|\n   * ```\n   *\n   * @factory true\n   * @return {Stream}\n   */\n  static empty(): Stream<any> {\n    return new Stream<any>({\n      _start(il: InternalListener<any>) { il._c(); },\n      _stop: noop,\n    });\n  }\n\n  /**\n   * Creates a Stream that immediately emits an \"error\" notification with the\n   * value you passed as the `error` argument when the stream starts, and that's\n   * it.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * throw(X)\n   * -X\n   * ```\n   *\n   * @factory true\n   * @param error The error event to emit on the created stream.\n   * @return {Stream}\n   */\n  static throw(error: any): Stream<any> {\n    return new Stream<any>({\n      _start(il: InternalListener<any>) { il._e(error); },\n      _stop: noop,\n    });\n  }\n\n  /**\n   * Creates a stream from an Array, Promise, or an Observable.\n   *\n   * @factory true\n   * @param {Array|PromiseLike|Observable} input The input to make a stream from.\n   * @return {Stream}\n   */\n  static from<T>(input: PromiseLike<T> | Stream<T> | Array<T> | Observable<T>): Stream<T> {\n    if (typeof input[$$observable] === 'function')\n      return Stream.fromObservable<T>(input as Observable<T>); else\n    if (typeof (input as PromiseLike<T>).then === 'function')\n      return Stream.fromPromise<T>(input as PromiseLike<T>); else\n    if (Array.isArray(input))\n      return Stream.fromArray<T>(input);\n\n    throw new TypeError(`Type of input to from() must be an Array, Promise, or Observable`);\n  }\n\n  /**\n   * Creates a Stream that immediately emits the arguments that you give to\n   * *of*, then completes.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * of(1,2,3)\n   * 123|\n   * ```\n   *\n   * @factory true\n   * @param a The first value you want to emit as an event on the stream.\n   * @param b The second value you want to emit as an event on the stream. One\n   * or more of these values may be given as arguments.\n   * @return {Stream}\n   */\n  static of<T>(...items: Array<T>): Stream<T> {\n    return Stream.fromArray<T>(items);\n  }\n\n  /**\n   * Converts an array to a stream. The returned stream will emit synchronously\n   * all the items in the array, and then complete.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * fromArray([1,2,3])\n   * 123|\n   * ```\n   *\n   * @factory true\n   * @param {Array} array The array to be converted as a stream.\n   * @return {Stream}\n   */\n  static fromArray<T>(array: Array<T>): Stream<T> {\n    return new Stream<T>(new FromArray<T>(array));\n  }\n\n  /**\n   * Converts a promise to a stream. The returned stream will emit the resolved\n   * value of the promise, and then complete. However, if the promise is\n   * rejected, the stream will emit the corresponding error.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * fromPromise( ----42 )\n   * -----------------42|\n   * ```\n   *\n   * @factory true\n   * @param {PromiseLike} promise The promise to be converted as a stream.\n   * @return {Stream}\n   */\n  static fromPromise<T>(promise: PromiseLike<T>): Stream<T> {\n    return new Stream<T>(new FromPromise<T>(promise));\n  }\n\n  /**\n   * Converts an Observable into a Stream.\n   *\n   * @factory true\n   * @param {any} observable The observable to be converted as a stream.\n   * @return {Stream}\n   */\n  static fromObservable<T>(obs: {subscribe: any}): Stream<T> {\n    if ((obs as Stream<T>).endWhen) return obs as Stream<T>;\n    const o = typeof obs[$$observable] === 'function' ? obs[$$observable]() : obs;\n    return new Stream<T>(new FromObservable(o));\n  }\n\n  /**\n   * Creates a stream that periodically emits incremental numbers, every\n   * `period` milliseconds.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   *     periodic(1000)\n   * ---0---1---2---3---4---...\n   * ```\n   *\n   * @factory true\n   * @param {number} period The interval in milliseconds to use as a rate of\n   * emission.\n   * @return {Stream}\n   */\n  static periodic(period: number): Stream<number> {\n    return new Stream<number>(new Periodic(period));\n  }\n\n  /**\n   * Blends multiple streams together, emitting events from all of them\n   * concurrently.\n   *\n   * *merge* takes multiple streams as arguments, and creates a stream that\n   * behaves like each of the argument streams, in parallel.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1----2-----3--------4---\n   * ----a-----b----c---d------\n   *            merge\n   * --1-a--2--b--3-c---d--4---\n   * ```\n   *\n   * @factory true\n   * @param {Stream} stream1 A stream to merge together with other streams.\n   * @param {Stream} stream2 A stream to merge together with other streams. Two\n   * or more streams may be given as arguments.\n   * @return {Stream}\n   */\n  static merge: MergeSignature = function merge(...streams: Array<Stream<any>>) {\n    return new Stream<any>(new Merge(streams));\n  } as MergeSignature;\n\n  /**\n   * Combines multiple input streams together to return a stream whose events\n   * are arrays that collect the latest events from each input stream.\n   *\n   * *combine* internally remembers the most recent event from each of the input\n   * streams. When any of the input streams emits an event, that event together\n   * with all the other saved events are combined into an array. That array will\n   * be emitted on the output stream. It's essentially a way of joining together\n   * the events from multiple streams.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1----2-----3--------4---\n   * ----a-----b-----c--d------\n   *          combine\n   * ----1a-2a-2b-3b-3c-3d-4d--\n   * ```\n   *\n   * @factory true\n   * @param {Stream} stream1 A stream to combine together with other streams.\n   * @param {Stream} stream2 A stream to combine together with other streams.\n   * Multiple streams, not just two, may be given as arguments.\n   * @return {Stream}\n   */\n  static combine: CombineSignature = function combine(...streams: Array<Stream<any>>) {\n    return new Stream<Array<any>>(new Combine<any>(streams));\n  } as CombineSignature;\n\n  protected _map<U>(project: (t: T) => U): Stream<U> | MemoryStream<U> {\n    return new (this.ctor())<U>(new MapOp<T, U>(project, this));\n  }\n\n  /**\n   * Transforms each event from the input Stream through a `project` function,\n   * to get a Stream that emits those transformed events.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---3--5-----7------\n   *    map(i => i * 10)\n   * --10--30-50----70-----\n   * ```\n   *\n   * @param {Function} project A function of type `(t: T) => U` that takes event\n   * `t` of type `T` from the input Stream and produces an event of type `U`, to\n   * be emitted on the output Stream.\n   * @return {Stream}\n   */\n  map<U>(project: (t: T) => U): Stream<U> {\n    return this._map(project);\n  }\n\n  /**\n   * It's like `map`, but transforms each input event to always the same\n   * constant value on the output Stream.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---3--5-----7-----\n   *       mapTo(10)\n   * --10--10-10----10----\n   * ```\n   *\n   * @param projectedValue A value to emit on the output Stream whenever the\n   * input Stream emits any value.\n   * @return {Stream}\n   */\n  mapTo<U>(projectedValue: U): Stream<U> {\n    const s = this.map(() => projectedValue);\n    const op: Operator<T, U> = s._prod as Operator<T, U>;\n    op.type = 'mapTo';\n    return s;\n  }\n\n  filter<S extends T>(passes: (t: T) => t is S): Stream<S>;\n  filter(passes: (t: T) => boolean): Stream<T>;\n  /**\n   * Only allows events that pass the test given by the `passes` argument.\n   *\n   * Each event from the input stream is given to the `passes` function. If the\n   * function returns `true`, the event is forwarded to the output stream,\n   * otherwise it is ignored and not forwarded.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---2--3-----4-----5---6--7-8--\n   *     filter(i => i % 2 === 0)\n   * ------2--------4---------6----8--\n   * ```\n   *\n   * @param {Function} passes A function of type `(t: T) => boolean` that takes\n   * an event from the input stream and checks if it passes, by returning a\n   * boolean.\n   * @return {Stream}\n   */\n  filter(passes: (t: T) => boolean): Stream<T> {\n    const p = this._prod;\n    if (p instanceof Filter)\n      return new Stream<T>(new Filter<T>(\n        and((p as Filter<T>).f, passes),\n        (p as Filter<T>).ins\n      ));\n    return new Stream<T>(new Filter<T>(passes, this));\n  }\n\n  /**\n   * Lets the first `amount` many events from the input stream pass to the\n   * output stream, then makes the output stream complete.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --a---b--c----d---e--\n   *    take(3)\n   * --a---b--c|\n   * ```\n   *\n   * @param {number} amount How many events to allow from the input stream\n   * before completing the output stream.\n   * @return {Stream}\n   */\n  take(amount: number): Stream<T> {\n    return new (this.ctor())<T>(new Take<T>(amount, this));\n  }\n\n  /**\n   * Ignores the first `amount` many events from the input stream, and then\n   * after that starts forwarding events from the input stream to the output\n   * stream.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --a---b--c----d---e--\n   *       drop(3)\n   * --------------d---e--\n   * ```\n   *\n   * @param {number} amount How many events to ignore from the input stream\n   * before forwarding all events from the input stream to the output stream.\n   * @return {Stream}\n   */\n  drop(amount: number): Stream<T> {\n    return new Stream<T>(new Drop<T>(amount, this));\n  }\n\n  /**\n   * When the input stream completes, the output stream will emit the last event\n   * emitted by the input stream, and then will also complete.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --a---b--c--d----|\n   *       last()\n   * -----------------d|\n   * ```\n   *\n   * @return {Stream}\n   */\n  last(): Stream<T> {\n    return new Stream<T>(new Last<T>(this));\n  }\n\n  /**\n   * Prepends the given `initial` value to the sequence of events emitted by the\n   * input stream. The returned stream is a MemoryStream, which means it is\n   * already `remember()`'d.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * ---1---2-----3---\n   *   startWith(0)\n   * 0--1---2-----3---\n   * ```\n   *\n   * @param initial The value or event to prepend.\n   * @return {MemoryStream}\n   */\n  startWith(initial: T): MemoryStream<T> {\n    return new MemoryStream<T>(new StartWith<T>(this, initial));\n  }\n\n  /**\n   * Uses another stream to determine when to complete the current stream.\n   *\n   * When the given `other` stream emits an event or completes, the output\n   * stream will complete. Before that happens, the output stream will behaves\n   * like the input stream.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * ---1---2-----3--4----5----6---\n   *   endWhen( --------a--b--| )\n   * ---1---2-----3--4--|\n   * ```\n   *\n   * @param other Some other stream that is used to know when should the output\n   * stream of this operator complete.\n   * @return {Stream}\n   */\n  endWhen(other: Stream<any>): Stream<T> {\n    return new (this.ctor())<T>(new EndWhen<T>(other, this));\n  }\n\n  /**\n   * \"Folds\" the stream onto itself.\n   *\n   * Combines events from the past throughout\n   * the entire execution of the input stream, allowing you to accumulate them\n   * together. It's essentially like `Array.prototype.reduce`. The returned\n   * stream is a MemoryStream, which means it is already `remember()`'d.\n   *\n   * The output stream starts by emitting the `seed` which you give as argument.\n   * Then, when an event happens on the input stream, it is combined with that\n   * seed value through the `accumulate` function, and the output value is\n   * emitted on the output stream. `fold` remembers that output value as `acc`\n   * (\"accumulator\"), and then when a new input event `t` happens, `acc` will be\n   * combined with that to produce the new `acc` and so forth.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * ------1-----1--2----1----1------\n   *   fold((acc, x) => acc + x, 3)\n   * 3-----4-----5--7----8----9------\n   * ```\n   *\n   * @param {Function} accumulate A function of type `(acc: R, t: T) => R` that\n   * takes the previous accumulated value `acc` and the incoming event from the\n   * input stream and produces the new accumulated value.\n   * @param seed The initial accumulated value, of type `R`.\n   * @return {MemoryStream}\n   */\n  fold<R>(accumulate: (acc: R, t: T) => R, seed: R): MemoryStream<R> {\n    return new MemoryStream<R>(new Fold<T, R>(accumulate, seed, this));\n  }\n\n  /**\n   * Replaces an error with another stream.\n   *\n   * When (and if) an error happens on the input stream, instead of forwarding\n   * that error to the output stream, *replaceError* will call the `replace`\n   * function which returns the stream that the output stream will replicate.\n   * And, in case that new stream also emits an error, `replace` will be called\n   * again to get another stream to start replicating.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1---2-----3--4-----X\n   *   replaceError( () => --10--| )\n   * --1---2-----3--4--------10--|\n   * ```\n   *\n   * @param {Function} replace A function of type `(err) => Stream` that takes\n   * the error that occurred on the input stream or on the previous replacement\n   * stream and returns a new stream. The output stream will behave like the\n   * stream that this function returns.\n   * @return {Stream}\n   */\n  replaceError(replace: (err: any) => Stream<T>): Stream<T> {\n    return new (this.ctor())<T>(new ReplaceError<T>(replace, this));\n  }\n\n  /**\n   * Flattens a \"stream of streams\", handling only one nested stream at a time\n   * (no concurrency).\n   *\n   * If the input stream is a stream that emits streams, then this operator will\n   * return an output stream which is a flat stream: emits regular events. The\n   * flattening happens without concurrency. It works like this: when the input\n   * stream emits a nested stream, *flatten* will start imitating that nested\n   * one. However, as soon as the next nested stream is emitted on the input\n   * stream, *flatten* will forget the previous nested one it was imitating, and\n   * will start imitating the new nested one.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --+--------+---------------\n   *   \\        \\\n   *    \\       ----1----2---3--\n   *    --a--b----c----d--------\n   *           flatten\n   * -----a--b------1----2---3--\n   * ```\n   *\n   * @return {Stream}\n   */\n  flatten<R>(this: Stream<Stream<R>>): T {\n    const p = this._prod;\n    return new Stream<R>(new Flatten(this)) as T & Stream<R>;\n  }\n\n  /**\n   * Passes the input stream to a custom operator, to produce an output stream.\n   *\n   * *compose* is a handy way of using an existing function in a chained style.\n   * Instead of writing `outStream = f(inStream)` you can write\n   * `outStream = inStream.compose(f)`.\n   *\n   * @param {function} operator A function that takes a stream as input and\n   * returns a stream as well.\n   * @return {Stream}\n   */\n  compose<U>(operator: (stream: Stream<T>) => U): U {\n    return operator(this);\n  }\n\n  /**\n   * Returns an output stream that behaves like the input stream, but also\n   * remembers the most recent event that happens on the input stream, so that a\n   * newly added listener will immediately receive that memorised event.\n   *\n   * @return {MemoryStream}\n   */\n  remember(): MemoryStream<T> {\n    return new MemoryStream<T>(new Remember<T>(this));\n  }\n\n  debug(): Stream<T>;\n  debug(labelOrSpy: string): Stream<T>;\n  debug(labelOrSpy: (t: T) => any): Stream<T>;\n  /**\n   * Returns an output stream that identically behaves like the input stream,\n   * but also runs a `spy` function for each event, to help you debug your app.\n   *\n   * *debug* takes a `spy` function as argument, and runs that for each event\n   * happening on the input stream. If you don't provide the `spy` argument,\n   * then *debug* will just `console.log` each event. This helps you to\n   * understand the flow of events through some operator chain.\n   *\n   * Please note that if the output stream has no listeners, then it will not\n   * start, which means `spy` will never run because no actual event happens in\n   * that case.\n   *\n   * Marble diagram:\n   *\n   * ```text\n   * --1----2-----3-----4--\n   *         debug\n   * --1----2-----3-----4--\n   * ```\n   *\n   * @param {function} labelOrSpy A string to use as the label when printing\n   * debug information on the console, or a 'spy' function that takes an event\n   * as argument, and does not need to return anything.\n   * @return {Stream}\n   */\n  debug(labelOrSpy?: string | ((t: T) => any)): Stream<T> {\n    return new (this.ctor())<T>(new Debug<T>(this, labelOrSpy));\n  }\n\n  /**\n   * *imitate* changes this current Stream to emit the same events that the\n   * `other` given Stream does. This method returns nothing.\n   *\n   * This method exists to allow one thing: **circular dependency of streams**.\n   * For instance, let's imagine that for some reason you need to create a\n   * circular dependency where stream `first$` depends on stream `second$`\n   * which in turn depends on `first$`:\n   *\n   * <!-- skip-example -->\n   * ```js\n   * import delay from 'xstream/extra/delay'\n   *\n   * var first$ = second$.map(x => x * 10).take(3);\n   * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));\n   * ```\n   *\n   * However, that is invalid JavaScript, because `second$` is undefined\n   * on the first line. This is how *imitate* can help solve it:\n   *\n   * ```js\n   * import delay from 'xstream/extra/delay'\n   *\n   * var secondProxy$ = xs.create();\n   * var first$ = secondProxy$.map(x => x * 10).take(3);\n   * var second$ = first$.map(x => x + 1).startWith(1).compose(delay(100));\n   * secondProxy$.imitate(second$);\n   * ```\n   *\n   * We create `secondProxy$` before the others, so it can be used in the\n   * declaration of `first$`. Then, after both `first$` and `second$` are\n   * defined, we hook `secondProxy$` with `second$` with `imitate()` to tell\n   * that they are \"the same\". `imitate` will not trigger the start of any\n   * stream, it just binds `secondProxy$` and `second$` together.\n   *\n   * The following is an example where `imitate()` is important in Cycle.js\n   * applications. A parent component contains some child components. A child\n   * has an action stream which is given to the parent to define its state:\n   *\n   * <!-- skip-example -->\n   * ```js\n   * const childActionProxy$ = xs.create();\n   * const parent = Parent({...sources, childAction$: childActionProxy$});\n   * const childAction$ = parent.state$.map(s => s.child.action$).flatten();\n   * childActionProxy$.imitate(childAction$);\n   * ```\n   *\n   * Note, though, that **`imitate()` does not support MemoryStreams**. If we\n   * would attempt to imitate a MemoryStream in a circular dependency, we would\n   * either get a race condition (where the symptom would be \"nothing happens\")\n   * or an infinite cyclic emission of values. It's useful to think about\n   * MemoryStreams as cells in a spreadsheet. It doesn't make any sense to\n   * define a spreadsheet cell `A1` with a formula that depends on `B1` and\n   * cell `B1` defined with a formula that depends on `A1`.\n   *\n   * If you find yourself wanting to use `imitate()` with a\n   * MemoryStream, you should rework your code around `imitate()` to use a\n   * Stream instead. Look for the stream in the circular dependency that\n   * represents an event stream, and that would be a candidate for creating a\n   * proxy Stream which then imitates the target Stream.\n   *\n   * @param {Stream} target The other stream to imitate on the current one. Must\n   * not be a MemoryStream.\n   */\n  imitate(target: Stream<T>): void {\n    if (target instanceof MemoryStream)\n      throw new Error('A MemoryStream was given to imitate(), but it only ' +\n      'supports a Stream. Read more about this restriction here: ' +\n      'https://github.com/staltz/xstream#faq');\n    this._target = target;\n    for (let ils = this._ils, N = ils.length, i = 0; i < N; i++) target._add(ils[i]);\n    this._ils = [];\n  }\n\n  /**\n   * Forces the Stream to emit the given value to its listeners.\n   *\n   * As the name indicates, if you use this, you are most likely doing something\n   * The Wrong Way. Please try to understand the reactive way before using this\n   * method. Use it only when you know what you are doing.\n   *\n   * @param value The \"next\" value you want to broadcast to all listeners of\n   * this Stream.\n   */\n  shamefullySendNext(value: T) {\n    this._n(value);\n  }\n\n  /**\n   * Forces the Stream to emit the given error to its listeners.\n   *\n   * As the name indicates, if you use this, you are most likely doing something\n   * The Wrong Way. Please try to understand the reactive way before using this\n   * method. Use it only when you know what you are doing.\n   *\n   * @param {any} error The error you want to broadcast to all the listeners of\n   * this Stream.\n   */\n  shamefullySendError(error: any) {\n    this._e(error);\n  }\n\n  /**\n   * Forces the Stream to emit the \"completed\" event to its listeners.\n   *\n   * As the name indicates, if you use this, you are most likely doing something\n   * The Wrong Way. Please try to understand the reactive way before using this\n   * method. Use it only when you know what you are doing.\n   */\n  shamefullySendComplete() {\n    this._c();\n  }\n\n  /**\n   * Adds a \"debug\" listener to the stream. There can only be one debug\n   * listener, that's why this is 'setDebugListener'. To remove the debug\n   * listener, just call setDebugListener(null).\n   *\n   * A debug listener is like any other listener. The only difference is that a\n   * debug listener is \"stealthy\": its presence/absence does not trigger the\n   * start/stop of the stream (or the producer inside the stream). This is\n   * useful so you can inspect what is going on without changing the behavior\n   * of the program. If you have an idle stream and you add a normal listener to\n   * it, the stream will start executing. But if you set a debug listener on an\n   * idle stream, it won't start executing (not until the first normal listener\n   * is added).\n   *\n   * As the name indicates, we don't recommend using this method to build app\n   * logic. In fact, in most cases the debug operator works just fine. Only use\n   * this one if you know what you're doing.\n   *\n   * @param {Listener<T>} listener\n   */\n  setDebugListener(listener: Partial<Listener<T>> | null | undefined) {\n    if (!listener) {\n      this._d = false;\n      this._dl = NO as InternalListener<T>;\n    } else {\n      this._d = true;\n      (listener as InternalListener<T>)._n = listener.next || noop;\n      (listener as InternalListener<T>)._e = listener.error || noop;\n      (listener as InternalListener<T>)._c = listener.complete || noop;\n      this._dl = listener as InternalListener<T>;\n    }\n  }\n}\n\nexport class MemoryStream<T> extends Stream<T> {\n  private _v: T;\n  private _has: boolean = false;\n  constructor(producer: InternalProducer<T>) {\n    super(producer);\n  }\n\n  _n(x: T) {\n    this._v = x;\n    this._has = true;\n    super._n(x);\n  }\n\n  _add(il: InternalListener<T>): void {\n    const ta = this._target;\n    if (ta !== NO) return ta._add(il);\n    const a = this._ils;\n    a.push(il);\n    if (a.length > 1) {\n      if (this._has) il._n(this._v);\n      return;\n    }\n    if (this._stopID !== NO) {\n      if (this._has) il._n(this._v);\n      clearTimeout(this._stopID);\n      this._stopID = NO;\n    } else if (this._has) il._n(this._v); else {\n      const p = this._prod;\n      if (p !== NO) p._start(this);\n    }\n  }\n\n  _stopNow() {\n    this._has = false;\n    super._stopNow();\n  }\n\n  _x(): void {\n    this._has = false;\n    super._x();\n  }\n\n  map<U>(project: (t: T) => U): MemoryStream<U> {\n    return this._map(project) as MemoryStream<U>;\n  }\n\n  mapTo<U>(projectedValue: U): MemoryStream<U> {\n    return super.mapTo(projectedValue) as MemoryStream<U>;\n  }\n\n  take(amount: number): MemoryStream<T> {\n    return super.take(amount) as MemoryStream<T>;\n  }\n\n  endWhen(other: Stream<any>): MemoryStream<T> {\n    return super.endWhen(other) as MemoryStream<T>;\n  }\n\n  replaceError(replace: (err: any) => Stream<T>): MemoryStream<T> {\n    return super.replaceError(replace) as MemoryStream<T>;\n  }\n\n  remember(): MemoryStream<T> {\n    return this;\n  }\n\n  debug(): MemoryStream<T>;\n  debug(labelOrSpy: string): MemoryStream<T>;\n  debug(labelOrSpy: (t: T) => any): MemoryStream<T>;\n  debug(labelOrSpy?: string | ((t: T) => any) | undefined): MemoryStream<T> {\n    return super.debug(labelOrSpy as any) as MemoryStream<T>;\n  }\n}\n\nexport {NO, NO_IL};\nconst xs = Stream;\ntype xs<T> = Stream<T>;\nexport default xs;\n","import {Stream, Producer, Listener} from 'xstream';\n\nexport type Predicate = (ev: any) => boolean;\nexport type PreventDefaultOpt = boolean | Predicate | Comparator;\nexport type Comparator = {[key: string]: any};\n\nexport function fromEvent(\n  element: Element | Document,\n  eventName: string,\n  useCapture = false,\n  preventDefault: PreventDefaultOpt = false,\n  passive = false\n): Stream<Event> {\n  let next: ((e: Event) => void) | null = null;\n  return Stream.create<Event>({\n    start: function start(listener: Listener<Event>) {\n      if (preventDefault) {\n        next = function _next(event: Event) {\n          preventDefaultConditional(event, preventDefault);\n          listener.next(event);\n        };\n      } else {\n        next = function _next(event: Event) {\n          listener.next(event);\n        };\n      }\n      element.addEventListener(eventName, next, {\n        capture: useCapture,\n        passive,\n      });\n    },\n    stop: function stop() {\n      element.removeEventListener(eventName, next as any, useCapture);\n      next = null;\n    },\n  } as Producer<Event>);\n}\n\nfunction matchObject(matcher: object, obj: object): boolean {\n  const keys = Object.keys(matcher);\n  const n = keys.length;\n  for (let i = 0; i < n; i++) {\n    const k = keys[i];\n    if (typeof matcher[k] === 'object' && typeof obj[k] === 'object') {\n      if (!matchObject(matcher[k], obj[k])) {\n        return false;\n      }\n    } else if (matcher[k] !== obj[k]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function preventDefaultConditional(\n  event: any,\n  preventDefault: PreventDefaultOpt\n): void {\n  if (preventDefault) {\n    if (typeof preventDefault === 'boolean') {\n      event.preventDefault();\n    } else if (isPredicate(preventDefault)) {\n      if (preventDefault(event)) {\n        event.preventDefault();\n      }\n    } else if (typeof preventDefault === 'object') {\n      if (matchObject(preventDefault, event)) {\n        event.preventDefault();\n      }\n    } else {\n      throw new Error(\n        'preventDefault has to be either a boolean, predicate function or object'\n      );\n    }\n  }\n}\n\nfunction isPredicate(fn: any): fn is Predicate {\n  return typeof fn === 'function';\n}\n","import xs, {Stream, MemoryStream} from 'xstream';\nimport {adapt} from '@cycle/run/lib/adapt';\nimport {DevToolEnabledSource} from '@cycle/run';\nimport {EventsFnOptions, DOMSource} from './DOMSource';\nimport {fromEvent} from './fromEvent';\n\nexport class DocumentDOMSource {\n  constructor(private _name: string) {}\n\n  public select(selector: string): DocumentDOMSource {\n    // This functionality is still undefined/undecided.\n    return this;\n  }\n\n  public elements(): MemoryStream<Array<Document>> {\n    const out: DevToolEnabledSource & MemoryStream<Array<Document>> = adapt(\n      xs.of([document])\n    );\n    out._isCycleSource = this._name;\n    return out;\n  }\n\n  public element(): MemoryStream<Document> {\n    const out: DevToolEnabledSource & MemoryStream<Document> = adapt(\n      xs.of(document)\n    );\n    out._isCycleSource = this._name;\n    return out;\n  }\n\n  public events<K extends keyof DocumentEventMap>(\n    eventType: K,\n    options?: EventsFnOptions,\n    bubbles?: boolean\n  ): Stream<DocumentEventMap[K]>;\n  public events(\n    eventType: string,\n    options: EventsFnOptions = {},\n    bubbles?: boolean\n  ): Stream<Event> {\n    let stream: Stream<Event>;\n\n    stream = fromEvent(\n      document,\n      eventType,\n      options.useCapture,\n      options.preventDefault\n    );\n\n    const out: DevToolEnabledSource & Stream<Event> = adapt(stream);\n    out._isCycleSource = this._name;\n    return out;\n  }\n}\n","import xs, {Stream, MemoryStream} from 'xstream';\nimport {adapt} from '@cycle/run/lib/adapt';\nimport {DevToolEnabledSource} from '@cycle/run';\nimport {EventsFnOptions, DOMSource} from './DOMSource';\nimport {fromEvent} from './fromEvent';\n\nexport class BodyDOMSource {\n  constructor(private _name: string) {}\n\n  public select(selector: string): BodyDOMSource {\n    // This functionality is still undefined/undecided.\n    return this;\n  }\n\n  public elements(): MemoryStream<Array<HTMLBodyElement>> {\n    const out: DevToolEnabledSource &\n      MemoryStream<Array<HTMLBodyElement>> = adapt(xs.of([document.body]));\n    out._isCycleSource = this._name;\n    return out;\n  }\n\n  public element(): MemoryStream<HTMLBodyElement> {\n    const out: DevToolEnabledSource & MemoryStream<HTMLBodyElement> = adapt(\n      xs.of(document.body)\n    );\n    out._isCycleSource = this._name;\n    return out;\n  }\n\n  public events<K extends keyof HTMLBodyElementEventMap>(\n    eventType: K,\n    options?: EventsFnOptions,\n    bubbles?: boolean\n  ): Stream<HTMLBodyElementEventMap[K]>;\n  public events(\n    eventType: string,\n    options: EventsFnOptions = {},\n    bubbles?: boolean\n  ): Stream<Event> {\n    let stream: Stream<Event>;\n\n    stream = fromEvent(\n      document.body,\n      eventType,\n      options.useCapture,\n      options.preventDefault\n    );\n\n    const out: DevToolEnabledSource & Stream<Event> = adapt(stream);\n    out._isCycleSource = this._name;\n    return out;\n  }\n}\n","import {Scope} from './isolate';\n\nfunction isValidNode(obj: any): obj is Element {\n  const ELEM_TYPE = 1;\n  const FRAG_TYPE = 11;\n  return typeof HTMLElement === 'object'\n    ? obj instanceof HTMLElement || obj instanceof DocumentFragment\n    : obj &&\n        typeof obj === 'object' &&\n        obj !== null &&\n        (obj.nodeType === ELEM_TYPE || obj.nodeType === FRAG_TYPE) &&\n        typeof obj.nodeName === 'string';\n}\n\nexport function isClassOrId(str: string): boolean {\n  return str.length > 1 && (str[0] === '.' || str[0] === '#');\n}\n\nexport function isDocFrag(\n  el: Element | DocumentFragment\n): el is DocumentFragment {\n  return el.nodeType === 11;\n}\n\nexport function checkValidContainer(\n  container: Element | DocumentFragment | string\n): void {\n  if (typeof container !== 'string' && !isValidNode(container)) {\n    throw new Error(\n      'Given container is not a DOM element neither a selector string.'\n    );\n  }\n}\n\nexport function getValidNode(\n  selectors: Element | DocumentFragment | string\n): Element | DocumentFragment | null {\n  const domElement =\n    typeof selectors === 'string'\n      ? document.querySelector(selectors)\n      : selectors;\n\n  if (typeof selectors === 'string' && domElement === null) {\n    throw new Error(`Cannot render into unknown element \\`${selectors}\\``);\n  }\n  return domElement;\n}\n\nexport function getSelectors(namespace: Array<Scope>): string {\n  let res = '';\n  for (let i = namespace.length - 1; i >= 0; i--) {\n    if (namespace[i].type !== 'selector') {\n      break;\n    }\n    res = namespace[i].scope + ' ' + res;\n  }\n  return res.trim();\n}\n\nexport function isEqualNamespace(\n  a: Array<Scope> | undefined,\n  b: Array<Scope> | undefined\n): boolean {\n  if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i].type !== b[i].type || a[i].scope !== b[i].scope) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function makeInsert(\n  map: Map<string, Map<Element, any>>\n): (type: string, elm: Element, value: any) => void {\n  return (type, elm, value) => {\n    if (map.has(type)) {\n      const innerMap = map.get(type)!;\n      innerMap.set(elm, value);\n    } else {\n      const innerMap = new Map<Element, any>();\n      innerMap.set(elm, value);\n      map.set(type, innerMap);\n    }\n  };\n}\n","import {IsolateModule} from './IsolateModule';\nimport {Scope} from './isolate';\nimport {isEqualNamespace} from './utils';\n\nexport class ScopeChecker {\n  public readonly _namespace: Array<Scope>;\n  constructor(\n    public readonly namespace: Array<Scope>,\n    private isolateModule: IsolateModule\n  ) {\n    this._namespace = namespace.filter(n => n.type !== 'selector');\n  }\n\n  /**\n   * Checks whether the given element is *directly* in the scope of this\n   * scope checker. Being contained *indirectly* through other scopes\n   * is not valid. This is crucial for implementing parent-child isolation,\n   * so that the parent selectors don't search inside a child scope.\n   */\n  public isDirectlyInScope(leaf: Element): boolean {\n    const namespace = this.isolateModule.getNamespace(leaf);\n    if (!namespace) {\n      return false;\n    }\n\n    if (\n      this._namespace.length > namespace.length ||\n      !isEqualNamespace(\n        this._namespace,\n        namespace.slice(0, this._namespace.length)\n      )\n    ) {\n      return false;\n    }\n    for (let i = this._namespace.length; i < namespace.length; i++) {\n      if (namespace[i].type === 'total') {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n","import {ScopeChecker} from './ScopeChecker';\nimport {getSelectors} from './utils';\nimport {Scope} from './isolate';\nimport {IsolateModule} from './IsolateModule';\n\nfunction toElArray(input: any): Array<Element> {\n  return Array.prototype.slice.call(input) as Array<Element>;\n}\n\nexport class ElementFinder {\n  constructor(\n    public namespace: Array<Scope>,\n    public isolateModule: IsolateModule\n  ) {}\n\n  public call(): Array<Element> {\n    const namespace = this.namespace;\n    const selector = getSelectors(namespace);\n\n    const scopeChecker = new ScopeChecker(namespace, this.isolateModule);\n    const topNode = this.isolateModule.getElement(\n      namespace.filter(n => n.type !== 'selector')\n    );\n\n    if (topNode === undefined) {\n      return [];\n    }\n\n    if (selector === '') {\n      return [topNode];\n    }\n\n    return toElArray(topNode.querySelectorAll(selector))\n      .filter(scopeChecker.isDirectlyInScope, scopeChecker)\n      .concat(topNode.matches(selector) ? [topNode] : []);\n  }\n}\n","import {Stream} from 'xstream';\nimport {VNode} from 'snabbdom';\nimport {isClassOrId} from './utils';\nimport {MainDOMSource} from './MainDOMSource';\n\nexport interface Scope {\n  type: 'sibling' | 'total' | 'selector';\n  scope: string; //Could be anything serializable\n}\n\nexport type IsolateSink<T extends VNode> = (\n  s: Stream<T>,\n  scope: string\n) => Stream<T>;\n\nexport function makeIsolateSink<T extends VNode>(\n  namespace: Array<Scope>\n): IsolateSink<T> {\n  return (sink, scope) => {\n    if (scope === ':root') {\n      return sink;\n    }\n\n    return sink.map(node => {\n      if (!node) {\n        return node;\n      }\n      const scopeObj = getScopeObj(scope);\n      const newNode = {\n        ...(node as any),\n        data: {\n          ...node.data,\n          isolate:\n            !node.data || !Array.isArray(node.data.isolate)\n              ? namespace.concat([scopeObj])\n              : node.data.isolate,\n        },\n      };\n      return {\n        ...newNode,\n        key:\n          newNode.key !== undefined\n            ? newNode.key\n            : JSON.stringify(newNode.data.isolate),\n      } as T;\n    });\n  };\n}\n\nexport function getScopeObj(scope: string): Scope {\n  return {\n    type: isClassOrId(scope) ? 'sibling' : 'total',\n    scope,\n  };\n}\n","import xs from 'xstream';\nimport {Stream, MemoryStream} from 'xstream';\nimport {DevToolEnabledSource} from '@cycle/run';\nimport {adapt} from '@cycle/run/lib/adapt';\nimport {DOMSource, EventsFnOptions} from './DOMSource';\nimport {DocumentDOMSource} from './DocumentDOMSource';\nimport {BodyDOMSource} from './BodyDOMSource';\nimport {VNode} from 'snabbdom';\nimport {ElementFinder} from './ElementFinder';\nimport {makeIsolateSink, getScopeObj, Scope, IsolateSink} from './isolate';\nimport {IsolateModule} from './IsolateModule';\nimport {EventDelegator} from './EventDelegator';\n\nexport interface SpecialSelector {\n  body: BodyDOMSource;\n  document: DocumentDOMSource;\n}\n\nexport class MainDOMSource {\n  constructor(\n    private _rootElement$: Stream<Element>,\n    private _sanitation$: Stream<null>,\n    private _namespace: Array<Scope> = [],\n    public _isolateModule: IsolateModule,\n    private _eventDelegator: EventDelegator,\n    private _name: string\n  ) {\n    this.isolateSource = (source, scope) =>\n      new MainDOMSource(\n        source._rootElement$,\n        source._sanitation$,\n        source._namespace.concat(getScopeObj(scope)),\n        source._isolateModule,\n        source._eventDelegator,\n        source._name\n      );\n    this.isolateSink = makeIsolateSink(this._namespace) as any;\n  }\n\n  private _elements(): Stream<Array<Element>> {\n    if (this._namespace.length === 0) {\n      return this._rootElement$.map(x => [x]);\n    } else {\n      const elementFinder = new ElementFinder(\n        this._namespace,\n        this._isolateModule\n      );\n      return this._rootElement$.map(() => elementFinder.call());\n    }\n  }\n\n  public elements(): MemoryStream<Array<Element>> {\n    const out: DevToolEnabledSource & MemoryStream<Array<Element>> = adapt(\n      this._elements().remember()\n    );\n    out._isCycleSource = this._name;\n    return out;\n  }\n\n  public element(): MemoryStream<Element> {\n    const out: DevToolEnabledSource & MemoryStream<Element> = adapt(\n      this._elements()\n        .filter(arr => arr.length > 0)\n        .map(arr => arr[0])\n        .remember()\n    );\n    out._isCycleSource = this._name;\n    return out;\n  }\n\n  get namespace(): Array<Scope> {\n    return this._namespace;\n  }\n\n  public select<T extends keyof SpecialSelector>(\n    selector: T\n  ): SpecialSelector[T];\n  public select(selector: string): MainDOMSource;\n  public select(selector: string): DOMSource {\n    if (typeof selector !== 'string') {\n      throw new Error(\n        `DOM driver's select() expects the argument to be a ` +\n          `string as a CSS selector`\n      );\n    }\n    if (selector === 'document') {\n      return new DocumentDOMSource(this._name);\n    }\n    if (selector === 'body') {\n      return new BodyDOMSource(this._name);\n    }\n\n    const namespace =\n      selector === ':root'\n        ? []\n        : this._namespace.concat({type: 'selector', scope: selector.trim()});\n\n    return new MainDOMSource(\n      this._rootElement$,\n      this._sanitation$,\n      namespace,\n      this._isolateModule,\n      this._eventDelegator,\n      this._name\n    ) as DOMSource;\n  }\n\n  public events<K extends keyof HTMLElementEventMap>(\n    eventType: K,\n    options?: EventsFnOptions,\n    bubbles?: boolean\n  ): Stream<HTMLElementEventMap[K]>;\n  public events(\n    eventType: string,\n    options: EventsFnOptions = {},\n    bubbles?: boolean\n  ): Stream<Event> {\n    if (typeof eventType !== `string`) {\n      throw new Error(\n        `DOM driver's events() expects argument to be a ` +\n          `string representing the event type to listen for.`\n      );\n    }\n    const event$: Stream<Event> = this._eventDelegator.addEventListener(\n      eventType,\n      this._namespace,\n      options,\n      bubbles\n    );\n\n    const out: DevToolEnabledSource & Stream<Event> = adapt(event$);\n    out._isCycleSource = this._name;\n    return out;\n  }\n\n  public dispose(): void {\n    this._sanitation$.shamefullySendNext(null);\n    //this._isolateModule.reset();\n  }\n\n  // The implementation of these are in the constructor so that their `this`\n  // references are automatically bound to the instance, so that library users\n  // can do destructuring `const {isolateSource, isolateSink} = sources.DOM` and\n  // not get bitten by a missing `this` reference.\n\n  public isolateSource: (source: MainDOMSource, scope: string) => MainDOMSource;\n  public isolateSink: IsolateSink<VNode>;\n}\n","import {Stream, InternalProducer, InternalListener, OutSender} from '../index';\n\nclass ConcatProducer<T> implements InternalProducer<T>, InternalListener<T>, OutSender<T> {\n  public type = 'concat';\n  public out: Stream<T> = null as any;\n  private i: number = 0;\n\n  constructor(public streams: Array<Stream<T>>) {\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.streams[this.i]._add(this);\n  }\n\n  _stop(): void {\n    const streams = this.streams;\n    if (this.i < streams.length) {\n      streams[this.i]._remove(this);\n    }\n    this.i = 0;\n    this.out = null as any;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (!u) return;\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (!u) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (!u) return;\n    const streams = this.streams;\n    streams[this.i]._remove(this);\n    if (++this.i < streams.length) {\n      streams[this.i]._add(this);\n    } else {\n      u._c();\n    }\n  }\n}\n\n/**\n * Puts one stream after the other. *concat* is a factory that takes multiple\n * streams as arguments, and starts the `n+1`-th stream only when the `n`-th\n * stream has completed. It concatenates those streams together.\n *\n * Marble diagram:\n *\n * ```text\n * --1--2---3---4-|\n * ...............--a-b-c--d-|\n *           concat\n * --1--2---3---4---a-b-c--d-|\n * ```\n *\n * Example:\n *\n * ```js\n * import concat from 'xstream/extra/concat'\n *\n * const streamA = xs.of('a', 'b', 'c')\n * const streamB = xs.of(10, 20, 30)\n * const streamC = xs.of('X', 'Y', 'Z')\n *\n * const outputStream = concat(streamA, streamB, streamC)\n *\n * outputStream.addListener({\n *   next: (x) => console.log(x),\n *   error: (err) => console.error(err),\n *   complete: () => console.log('concat completed'),\n * })\n * ```\n *\n * @factory true\n * @param {Stream} stream1 A stream to concatenate together with other streams.\n * @param {Stream} stream2 A stream to concatenate together with other streams. Two\n * or more streams may be given as arguments.\n * @return {Stream}\n */\nexport default function concat<T>(...streams: Array<Stream<T>>): Stream<T> {\n  return new Stream<T>(new ConcatProducer(streams));\n}\n","import {InternalListener, Operator, Stream} from '../index';\n\nexport interface SampleCombineSignature {\n  (): <T>(s: Stream<T>) => Stream<[T]>;\n  <T1>(s1: Stream<T1>): <T>(s: Stream<T>) => Stream<[T, T1]>;\n  <T1, T2>(\n    s1: Stream<T1>,\n    s2: Stream<T2>): <T>(s: Stream<T>) => Stream<[T, T1, T2]>;\n  <T1, T2, T3>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>): <T>(s: Stream<T>) => Stream<[T, T1, T2, T3]>;\n  <T1, T2, T3, T4>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>): <T>(s: Stream<T>) => Stream<[T, T1, T2, T3, T4]>;\n  <T1, T2, T3, T4, T5>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>): <T>(s: Stream<T>) => Stream<[T, T1, T2, T3, T4, T5]>;\n  <T1, T2, T3, T4, T5, T6>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>): <T>(s: Stream<T>) => Stream<[T, T1, T2, T3, T4, T5, T6]>;\n  <T1, T2, T3, T4, T5, T6, T7>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>): <T>(s: Stream<T>) => Stream<[T, T1, T2, T3, T4, T5, T6, T7]>;\n  <T1, T2, T3, T4, T5, T6, T7, T8>(\n    s1: Stream<T1>,\n    s2: Stream<T2>,\n    s3: Stream<T3>,\n    s4: Stream<T4>,\n    s5: Stream<T5>,\n    s6: Stream<T6>,\n    s7: Stream<T7>,\n    s8: Stream<T8>): <T>(s: Stream<T>) => Stream<[T, T1, T2, T3, T4, T5, T6, T7, T8]>;\n  (...streams: Array<Stream<any>>): (s: Stream<any>) => Stream<Array<any>>;\n}\n\nconst NO = {};\n\nexport class SampleCombineListener<T> implements InternalListener<T> {\n  constructor(private i: number, private p: SampleCombineOperator<any>) {\n    p.ils[i] = this;\n  }\n\n  _n(t: T): void {\n    const p = this.p;\n    if (p.out === NO) return;\n    p.up(t, this.i);\n  }\n\n  _e(err: any): void {\n    this.p._e(err);\n  }\n\n  _c(): void {\n    this.p.down(this.i, this);\n  }\n}\n\nexport class SampleCombineOperator<T> implements Operator<T, Array<any>> {\n  public type = 'sampleCombine';\n  public ins: Stream<T>;\n  public others: Array<Stream<any>>;\n  public out: Stream<Array<any>>;\n  public ils: Array<SampleCombineListener<any>>;\n  public Nn: number; // *N*umber of streams still to send *n*ext\n  public vals: Array<any>;\n\n  constructor(ins: Stream<T>, streams: Array<Stream<any>>) {\n    this.ins = ins;\n    this.others = streams;\n    this.out = NO as Stream<Array<any>>;\n    this.ils = [];\n    this.Nn = 0;\n    this.vals = [];\n  }\n\n  _start(out: Stream<Array<any>>): void {\n    this.out = out;\n    const s = this.others;\n    const n = this.Nn = s.length;\n    const vals = this.vals = new Array(n);\n    for (let i = 0; i < n; i++) {\n      vals[i] = NO;\n      s[i]._add(new SampleCombineListener<any>(i, this));\n    }\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    const s = this.others;\n    const n = s.length;\n    const ils = this.ils;\n    this.ins._remove(this);\n    for (let i = 0; i < n; i++) {\n      s[i]._remove(ils[i]);\n    }\n    this.out = NO as Stream<Array<any>>;\n    this.vals = [];\n    this.ils = [];\n  }\n\n  _n(t: T): void {\n    const out = this.out;\n    if (out === NO) return;\n    if (this.Nn > 0) return;\n    out._n([t, ...this.vals]);\n  }\n\n  _e(err: any): void {\n    const out = this.out;\n    if (out === NO) return;\n    out._e(err);\n  }\n\n  _c(): void {\n    const out = this.out;\n    if (out === NO) return;\n    out._c();\n  }\n\n  up(t: any, i: number): void {\n    const v = this.vals[i];\n    if (this.Nn > 0 && v === NO) {\n      this.Nn--;\n    }\n    this.vals[i] = t;\n  }\n\n  down(i: number, l: SampleCombineListener<any>): void {\n    this.others[i]._remove(l);\n  }\n}\n\nlet sampleCombine: SampleCombineSignature;\n\n/**\n *\n * Combines a source stream with multiple other streams. The result stream\n * will emit the latest events from all input streams, but only when the\n * source stream emits.\n *\n * If the source, or any input stream, throws an error, the result stream\n * will propagate the error. If any input streams end, their final emitted\n * value will remain in the array of any subsequent events from the result\n * stream.\n *\n * The result stream will only complete upon completion of the source stream.\n *\n * Marble diagram:\n *\n * ```text\n * --1----2-----3--------4--- (source)\n * ----a-----b-----c--d------ (other)\n *      sampleCombine\n * -------2a----3b-------4d--\n * ```\n *\n * Examples:\n *\n * ```js\n * import sampleCombine from 'xstream/extra/sampleCombine'\n * import xs from 'xstream'\n *\n * const sampler = xs.periodic(1000).take(3)\n * const other = xs.periodic(100)\n *\n * const stream = sampler.compose(sampleCombine(other))\n *\n * stream.addListener({\n *   next: i => console.log(i),\n *   error: err => console.error(err),\n *   complete: () => console.log('completed')\n * })\n * ```\n *\n * ```text\n * > [0, 8]\n * > [1, 18]\n * > [2, 28]\n * ```\n *\n * ```js\n * import sampleCombine from 'xstream/extra/sampleCombine'\n * import xs from 'xstream'\n *\n * const sampler = xs.periodic(1000).take(3)\n * const other = xs.periodic(100).take(2)\n *\n * const stream = sampler.compose(sampleCombine(other))\n *\n * stream.addListener({\n *   next: i => console.log(i),\n *   error: err => console.error(err),\n *   complete: () => console.log('completed')\n * })\n * ```\n *\n * ```text\n * > [0, 1]\n * > [1, 1]\n * > [2, 1]\n * ```\n *\n * @param {...Stream} streams One or more streams to combine with the sampler\n * stream.\n * @return {Stream}\n */\nsampleCombine = function sampleCombine(...streams: Array<Stream<any>>) {\n  return function sampleCombineOperator(sampler: Stream<any>): Stream<Array<any>> {\n    return new Stream<Array<any>>(new SampleCombineOperator(sampler, streams));\n  };\n} as SampleCombineSignature;\n\nexport default sampleCombine;","import { VNode } from 'snabbdom';\nimport { Select, Selector } from './types';\n\nexport function curry2 (select: Select): Selector {\n  return function selector (sel: string, vNode: VNode): any {\n    switch (arguments.length) {\n      case 0: return select;\n      case 1: return (_vNode: VNode) => select(sel, _vNode);\n      default: return select(sel, vNode);\n    }\n  } as Selector;\n}\n","export interface Selector {\n    tag: string;\n    id: string;\n    classList: string[];\n    attributes: Attributes;\n    nextSelector: [Combinator, Selector] | undefined;\n    pseudos: Pseudo[];\n}\n\nexport type Pseudo =\n    | ['first-child', undefined]\n    | ['last-child', undefined]\n    | ['nth-child', string]\n    | ['empty', undefined]\n    | ['root', undefined]\n    | ['contains', string];\n\nexport interface Attributes {\n    [attr: string]: [AttributeMatch, string | number | boolean];\n}\n\nexport type AttributeMatch =\n    | 'exact'\n    | 'has'\n    | 'startsWith'\n    | 'endsWith'\n    | 'contains'\n    | 'whitespace'\n    | 'dash';\n\nexport type Combinator = 'subtree' | 'child' | 'nextSibling' | 'sibling';\n\nconst IDENT = '[\\\\w-]+';\nconst SPACE = '[ \\t]*';\nconst VALUE = `[^\\\\]]+`;\n\nconst CLASS = `(?:\\\\.${IDENT})`;\nconst ID = `(?:#${IDENT})`;\n\nconst OP = `(?:=|\\\\$=|\\\\^=|\\\\*=|~=|\\\\|=)`;\nconst ATTR = `(?:\\\\[${SPACE}${IDENT}${SPACE}(?:${OP}${SPACE}${VALUE}${SPACE})?\\\\])`;\n\nconst SUBTREE = `(?:[ \\t]+)`;\nconst CHILD = `(?:${SPACE}(>)${SPACE})`;\nconst NEXT_SIBLING = `(?:${SPACE}(\\\\+)${SPACE})`;\nconst SIBLING = `(?:${SPACE}(~)${SPACE})`;\n\nconst COMBINATOR = `(?:${SUBTREE}|${CHILD}|${NEXT_SIBLING}|${SIBLING})`;\n\nconst CONTAINS = `contains\\\\(\"[^\"]*\"\\\\)`;\nconst FORMULA = `(?:even|odd|\\\\d*(?:-?n(?:\\\\+\\\\d+)?)?)`;\nconst NTH_CHILD = `nth-child\\\\(${FORMULA}\\\\)`;\n\nconst PSEUDO = `:(?:first-child|last-child|${NTH_CHILD}|empty|root|${CONTAINS})`;\n\nconst TAG = `(:?${IDENT})?`;\nconst TOKENS = `${CLASS}|${ID}|${ATTR}|${PSEUDO}|${COMBINATOR}`;\n\nconst combinatorRegex = new RegExp(`^${COMBINATOR}$`);\n\n/**\n * Parses a css selector into a normalized object.\n * Expects a selector for a single element only, no `>` or the like!\n */\nexport function parseSelector(selector: string): Selector {\n    const sel = selector.trim();\n    let tagRegex = new RegExp(TAG, 'y');\n    const [tag] = (tagRegex.exec(sel) as any) as [string];\n\n    const regex = new RegExp(TOKENS, 'y');\n    regex.lastIndex = tagRegex.lastIndex;\n\n    const matches: string[] = [];\n\n    let nextSelector = undefined;\n    let lastCombinator = undefined;\n    let index = -1;\n\n    while (regex.lastIndex < sel.length) {\n        const match = regex.exec(sel);\n        if (!match && lastCombinator === undefined) {\n            throw new Error('Parse error, invalid selector');\n        } else if (match && combinatorRegex.test(match[0])) {\n            const comb = (combinatorRegex.exec(match[0]) as string[])[0];\n            lastCombinator = comb;\n            index = regex.lastIndex;\n        } else {\n            if (lastCombinator !== undefined) {\n                nextSelector = [\n                    getCombinator(lastCombinator),\n                    parseSelector(sel.substring(index))\n                ] as [Combinator, Selector];\n                break;\n            }\n            matches.push((match as string[])[0]);\n        }\n    }\n\n    const classList = matches\n        .filter(s => s.startsWith('.'))\n        .map(s => s.substring(1));\n\n    const ids = matches.filter(s => s.startsWith('#')).map(s => s.substring(1));\n\n    if (ids.length > 1) {\n        throw new Error('Invalid selector, only one id is allowed');\n    }\n\n    const postprocessRegex = new RegExp(\n        `(${IDENT})${SPACE}(${OP})?${SPACE}(${VALUE})?`\n    );\n    const attrs = matches\n        .filter(s => s.startsWith('['))\n        .map(s => (postprocessRegex.exec(s) as string[]).slice(1, 4))\n        .map(([attr, op, val]) => ({\n            [attr]: [getOp(op), val ? parseAttrValue(val) : val]\n        }))\n        .reduce((acc, curr) => ({ ...acc, ...curr }), {}) as Attributes;\n\n    const pseudos = matches\n        .filter(s => s.startsWith(':'))\n        .map(s => postProcessPseudos(s.substring(1)));\n\n    return {\n        id: ids[0] || '',\n        tag,\n        classList,\n        attributes: attrs,\n        nextSelector,\n        pseudos\n    };\n}\n\nfunction parseAttrValue(v: string): string | boolean | number {\n    if(v.startsWith('\"')) {\n        return v.slice(1, -1);\n    }\n    if(v === \"true\") {\n        return true;\n    }\n    if(v === \"false\") {\n        return false;\n    }\n    const f = parseFloat(v);\n    if(isNaN(f)) {\n        return v;\n    }\n    return f;\n}\n\nfunction postProcessPseudos(sel: string): Pseudo {\n    if (\n        sel === 'first-child' ||\n        sel === 'last-child' ||\n        sel === 'root' ||\n        sel === 'empty'\n    ) {\n        return [sel, undefined] as Pseudo;\n    }\n    if (sel.startsWith('contains')) {\n        const text = sel.slice(10, -2);\n        return ['contains', text];\n    }\n\n    let content = sel.slice(10, -1);\n    if (content === 'even') {\n        content = '2n';\n    }\n    if (content === 'odd') {\n        content = '2n+1';\n    }\n    return ['nth-child', content];\n}\n\nfunction getOp(op: string): string {\n    switch (op) {\n        case '=':\n            return 'exact';\n        case '^=':\n            return 'startsWith';\n        case '$=':\n            return 'endsWith';\n        case '*=':\n            return 'contains';\n        case '~=':\n            return 'whitespace';\n        case '|=':\n            return 'dash';\n        default:\n            return 'has';\n    }\n}\n\nfunction getCombinator(comb: string): string {\n    switch (comb.trim()) {\n        case '>':\n            return 'child';\n        case '+':\n            return 'nextSibling';\n        case '~':\n            return 'sibling';\n        default:\n            return 'subtree';\n    }\n}\n","import { Options } from './types';\nimport { parseSelector, Selector } from './selectorParser';\n\nexport function createMatches<T>(\n    opts: Options<T>\n): (selector: string | Selector, node: T) => boolean {\n    return function matches(selector: string | Selector, node: T | undefined): boolean {\n        const { tag, id, classList, attributes, nextSelector, pseudos } =\n            typeof selector === 'object' ? selector : parseSelector(selector);\n\n        if (nextSelector !== undefined) {\n            throw new Error(\n                'matches can only process selectors that target a single element'\n            );\n        }\n        if(!node) {\n            return false;\n        }\n\n        if (tag && tag.toLowerCase() !== opts.tag(node).toLowerCase()) {\n            return false;\n        }\n        if (id && id !== opts.id(node)) {\n            return false;\n        }\n        const classes = opts.className(node).split(' ');\n        for (let i = 0; i < classList.length; i++) {\n            if (classes.indexOf(classList[i]) === -1) {\n                return false;\n            }\n        }\n\n        for (let key in attributes) {\n            const attr = opts.attr(node, key);\n            const t = attributes[key][0];\n            const v = attributes[key][1];\n\n            if (attr === undefined) {\n                return false;\n            }\n            if (t === 'has') {\n                return true;\n            }\n            if (t === 'exact' && attr !== v) {\n                return false;\n            } else if(t !== 'exact') {\n                if(typeof v !== 'string') {\n                    throw new Error('All non-string values have to be an exact match');\n                }\n                if (t === 'startsWith' && !attr.startsWith(v)) {\n                    return false;\n                }\n                if (t === 'endsWith' && !attr.endsWith(v)) {\n                    return false;\n                }\n                if (t === 'contains' && attr.indexOf(v) === -1) {\n                    return false;\n                }\n                if (t === 'whitespace' && attr.split(' ').indexOf(v) === -1) {\n                    return false;\n                }\n                if (t === 'dash' && attr.split('-').indexOf(v) === -1) {\n                    return false;\n                }\n            }\n        }\n\n        for (let i = 0; i < pseudos.length; i++) {\n            const [t, data] = pseudos[i];\n            if (t === 'contains' && data !== opts.contents(node)) {\n                return false;\n            }\n            if (\n                t === 'empty' &&\n                (opts.contents(node) || opts.children(node).length !== 0)\n            ) {\n                return false;\n            }\n            if (t === 'root' && opts.parent(node) !== undefined) {\n                return false;\n            }\n            if (t.indexOf('child') !== -1) {\n                if (!opts.parent(node)) {\n                    return false;\n                }\n                const siblings = opts.children(opts.parent(node) as T);\n                if (t === 'first-child' && siblings.indexOf(node) !== 0) {\n                    return false;\n                }\n                if (\n                    t === 'last-child' &&\n                    siblings.indexOf(node) !== siblings.length - 1\n                ) {\n                    return false;\n                }\n                if (t === 'nth-child') {\n                    const regex = /([\\+-]?)(\\d*)(n?)(\\+\\d+)?/;\n                    const parseResult = (regex.exec(\n                        data as string\n                    ) as string[]).slice(1);\n                    const index = siblings.indexOf(node);\n                    if (!parseResult[0]) {\n                        parseResult[0] = '+';\n                    }\n                    const factor = parseResult[1]\n                        ? parseInt(parseResult[0] + parseResult[1])\n                        : undefined;\n                    const add = parseInt(parseResult[3] || '0');\n                    if (\n                        factor &&\n                        parseResult[2] === 'n' &&\n                        index % factor !== add\n                    ) {\n                        return false;\n                    } else if (\n                        !factor &&\n                        parseResult[2] &&\n                        ((parseResult[0] === '+' && index - add < 0) ||\n                            (parseResult[0] === '-' && index - add >= 0))\n                    ) {\n                        return false;\n                    } else if (\n                        !parseResult[2] && factor &&\n                        index !== factor - 1\n                    ) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    };\n}\n","import { Selector, parseSelector, Combinator } from './selectorParser';\nimport { Options } from './types';\nimport { createMatches } from './matches';\n\nexport function createQuerySelector<T>(\n    options: Options<T>,\n    matches?: (sel: string | Selector, node: T) => T | boolean\n): (sel: string | Selector, node: T) => T[] {\n    const _matches = matches || createMatches(options);\n\n    function findSubtree(selector: Selector, depth: number, node: T | undefined): T[] {\n        if(!node) {\n            return [];\n        }\n        const n = _matches(selector, node);\n        const matched = n ? (typeof n === 'object' ? [n] : [node]) : [];\n        if (depth === 0) {\n            return matched;\n        }\n        const childMatched = options\n            .children(node)\n            .filter(c => typeof c !== 'string')\n            .map(c => findSubtree(selector, depth - 1, c as T))\n            .reduce((acc, curr) => acc.concat(curr), []);\n\n        return matched.concat(childMatched);\n    }\n\n    function findSibling(selector: Selector, next: boolean, node: T | undefined): T[] {\n        if (!node || options.parent(node) === undefined) {\n            return [];\n        }\n\n        let results: T[] = [];\n        const siblings = options.children(options.parent(node) as T);\n\n        for (let i = siblings.indexOf(node) + 1; i < siblings.length; i++) {\n            if (typeof siblings[i] === 'string') {\n                continue;\n            }\n            const n = _matches(selector, siblings[i] as T);\n            if (n) {\n                if(typeof n === 'object') {\n                    results.push(n);\n                } else {\n                    results.push(siblings[i] as T);\n                }\n            }\n\n            if (next) {\n                break;\n            }\n        }\n\n        return results;\n    }\n\n    return function querySelector(selector: string | Selector, node: T | undefined): T[] {\n        if(!node) {\n            return [];\n        }\n        const sel =\n            typeof selector === 'object' ? selector : parseSelector(selector);\n\n        let results: T[] = [node];\n\n        let currentSelector = sel;\n        let currentCombinator: Combinator = 'subtree';\n        let tail = undefined;\n        do {\n            tail = currentSelector.nextSelector;\n            currentSelector.nextSelector = undefined;\n\n            if (\n                currentCombinator === 'subtree' ||\n                currentCombinator === 'child'\n            ) {\n                const depth = currentCombinator === 'subtree' ? Infinity : 1;\n\n                results = results\n                    .map(n => findSubtree(currentSelector, depth, n))\n                    .reduce((acc, curr) => acc.concat(curr), []);\n            } else {\n                const next = currentCombinator === 'nextSibling';\n\n                results = results\n                    .map(n => findSibling(currentSelector, next, n))\n                    .reduce((acc, curr) => acc.concat(curr), []);\n            }\n\n            if (tail) {\n                currentSelector = tail[1];\n                currentCombinator = tail[0];\n            }\n        } while (tail !== undefined);\n\n        return results;\n    };\n}\n","export * from './selectorParser';\nexport { createMatches } from './matches';\nexport { Options } from './types';\nexport { createQuerySelector } from './querySelector';\n","import { VNode } from 'snabbdom';\nimport { selectorParser } from './selectorParser';\n\nexport function classNameFromVNode(vNode: VNode): string {\n  let { className: cn = '' } = selectorParser(vNode);\n\n  if (!vNode.data) {\n    return cn;\n  }\n\n  const {class: dataClass, props} = vNode.data;\n\n  if (dataClass) {\n    const c = Object.keys(dataClass)\n      .filter((cl: string) => dataClass[cl]);\n\n    cn += ` ${c.join(` `)}`;\n  }\n\n  if (props && props.className) {\n    cn += ` ${props.className}`;\n  }\n\n  return cn && cn.trim();\n}\n","declare var global: any;\n\nlet root: any;\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else {\n  root = Function('return this')();\n}\n\nconst Symbol = root.Symbol;\n\nlet parentSymbol: symbol;\nif (typeof Symbol === 'function') {\n  parentSymbol = Symbol('parent');\n} else {\n  parentSymbol = '@@snabbdom-selector-parent' as any;\n}\n\nexport default parentSymbol;\n","import { Options, createQuerySelector, createMatches, Selector } from 'tree-selector';\nimport { VNode } from 'snabbdom';\nimport { selectorParser } from './selectorParser';\nimport { classNameFromVNode } from './classNameFromVNode';\nimport parentSymbol from './parent-symbol';\nimport { Select } from './types';\n\nconst options: Options<VNode> = {\n  tag: (vNode: VNode) => selectorParser(vNode).tagName,\n  className: (vNode: VNode) => classNameFromVNode(vNode),\n  id: (vNode: VNode) => selectorParser(vNode).id || '',\n  children: (vNode: VNode) => vNode.children || [],\n  parent: (vNode: VNode) => (vNode.data as any)[parentSymbol] || vNode,\n  contents: (vNode: VNode) => vNode.text || '',\n  attr (vNode: VNode, attr: string) {\n    if (vNode.data) {\n      const { attrs = {}, props = {}, dataset = {} } = vNode.data;\n      if (attrs[attr]) {\n        return attrs[attr];\n      }\n      if (props[attr]) {\n        return props[attr];\n      }\n      if (attr.indexOf('data-') === 0 && dataset[attr.slice(5)]) {\n        return dataset[attr.slice(5)];\n      }\n    }\n  },\n};\n\nconst matches = createMatches(options);\n\nfunction customMatches(sel: string | Selector, vnode: VNode): VNode | boolean {\n  const { data } = vnode;\n  const selector = matches.bind(null, sel);\n\n  if (data && data.fn) {\n    let n: VNode;\n    if (Array.isArray(data.args)) {\n      n = data.fn.apply(null, data.args);\n    } else if (data.args) {\n      n = data.fn.call(null, data.args);\n    } else {\n      n = data.fn();\n    }\n    return selector(n) ? n : false;\n  }\n  return selector(vnode);\n}\n\nexport const querySelector: Select = createQuerySelector(options, customMatches) as any;\n","import { VNode } from 'snabbdom';\nimport { querySelector } from './query';\nimport parentSymbol from './parent-symbol';\n\nexport function findMatches (cssSelector: string, vNode: VNode | undefined): Array<VNode> {\n  if (!vNode) {\n    return [];\n  }\n  traverseVNode(vNode, addParent); // add mapping to the parent selectorParser\n\n  return querySelector(cssSelector, vNode);\n}\n\nfunction traverseVNode (vNode: VNode,\n                        f: (vNode: VNode,\n                            root: boolean,\n                            parent?: VNode) => any): void {\n\n  function recurse (currentNode: VNode, isParent: boolean, parentVNode?: VNode) {\n    const length = currentNode.children && currentNode.children.length || 0;\n\n    for (let i = 0; i < length; ++i) {\n      const { children } = currentNode;\n\n      if (children && children[i] && typeof children[i] !== 'string') {\n        const child = children[i];\n        recurse(child as VNode, false, currentNode);\n      }\n    }\n\n    f(currentNode, isParent, isParent ? void 0 : parentVNode);\n  }\n\n  recurse(vNode, true);\n}\n\nfunction addParent (vNode: VNode, isParent: boolean, parent?: VNode): void {\n  if (isParent) { return void 0; }\n\n  if (!vNode.data) {\n    vNode.data = {};\n  }\n\n  if (!vNode.data[parentSymbol as any]) {\n    Object.defineProperty(vNode.data, parentSymbol, {\n      value: parent,\n    });\n  }\n}\n","import {h, VNode, vnode as vnodeFn} from 'snabbdom';\nimport {classNameFromVNode, selectorParser} from 'snabbdom-selector';\nimport {isDocFrag} from './utils';\n\nexport class VNodeWrapper {\n  constructor(public rootElement: Element | DocumentFragment) {}\n\n  public call(vnode: VNode | null): VNode {\n    if (isDocFrag(this.rootElement)) {\n      return this.wrapDocFrag(vnode === null ? [] : [vnode]);\n    }\n    if (vnode === null) {\n      return this.wrap([]);\n    }\n    const {tagName: selTagName, id: selId} = selectorParser(vnode);\n    const vNodeClassName = classNameFromVNode(vnode);\n    const vNodeData = vnode.data || {};\n    const vNodeDataProps = vNodeData.props || {};\n    const {id: vNodeId = selId} = vNodeDataProps;\n\n    const isVNodeAndRootElementIdentical =\n      typeof vNodeId === 'string' &&\n      vNodeId.toUpperCase() === this.rootElement.id.toUpperCase() &&\n      selTagName.toUpperCase() === this.rootElement.tagName.toUpperCase() &&\n      vNodeClassName.toUpperCase() === this.rootElement.className.toUpperCase();\n\n    if (isVNodeAndRootElementIdentical) {\n      return vnode;\n    }\n\n    return this.wrap([vnode]);\n  }\n\n  private wrapDocFrag(children: Array<VNode>) {\n    return vnodeFn('', {isolate: []}, children, undefined, this\n      .rootElement as any);\n  }\n\n  private wrap(children: Array<VNode>) {\n    const {tagName, id, className} = this.rootElement as Element;\n    const selId = id ? `#${id}` : '';\n    const selClass = className ? `.${className.split(` `).join(`.`)}` : '';\n    const vnode = h(\n      `${tagName.toLowerCase()}${selId}${selClass}`,\n      {},\n      children\n    );\n    vnode.data = vnode.data || {};\n    vnode.data.isolate = vnode.data.isolate || [];\n    return vnode;\n  }\n}\n","import {Module, classModule, propsModule, attributesModule, styleModule, datasetModule} from 'snabbdom';\n\nconst modules: Array<Module> = [\n  styleModule,\n  classModule,\n  propsModule,\n  attributesModule,\n  datasetModule,\n];\n\nexport {styleModule, classModule, propsModule, attributesModule, datasetModule};\n\nexport default modules;\n","type Node<Payload> = [Payload | undefined, InternalTree<Payload>];\n\ninterface InternalTree<Payload> {\n  [name: string]: Node<Payload>;\n}\n\nexport default class SymbolTree<Payload, T> {\n  private tree: Node<Payload> = [undefined, {}];\n\n  constructor(private mapper: (t: T) => string) {}\n\n  public set(path: Array<T>, element: Payload | undefined, max?: number): void {\n    let curr = this.tree;\n    const _max = max !== undefined ? max : path.length;\n    for (let i = 0; i < _max; i++) {\n      const n = this.mapper(path[i]);\n      let child: Node<Payload> = curr[1][n];\n      if (!child) {\n        child = [undefined, {}];\n        curr[1][n] = child;\n      }\n      curr = child;\n    }\n    curr[0] = element;\n  }\n\n  public getDefault(\n    path: Array<T>,\n    mkDefaultElement: () => Payload,\n    max?: number\n  ): Payload {\n    return this.get(path, mkDefaultElement, max) as Payload;\n  }\n\n  /**\n   * Returns the payload of the path\n   * If a default element creator is given, it will insert it at the path\n   */\n  public get(\n    path: Array<T>,\n    mkDefaultElement?: () => Payload,\n    max?: number\n  ): Payload | undefined {\n    let curr = this.tree;\n    const _max = max !== undefined ? max : path.length;\n    for (let i = 0; i < _max; i++) {\n      const n = this.mapper(path[i]);\n      let child: Node<Payload> = curr[1][n];\n      if (!child) {\n        if (mkDefaultElement) {\n          child = [undefined, {}];\n          curr[1][n] = child;\n        } else {\n          return undefined;\n        }\n      }\n      curr = child;\n    }\n    if (mkDefaultElement && !curr[0]) {\n      curr[0] = mkDefaultElement();\n    }\n    return curr[0];\n  }\n\n  public delete(path: Array<T>): void {\n    let curr = this.tree;\n    for (let i = 0; i < path.length - 1; i++) {\n      const child = curr[1][this.mapper(path[i])];\n      if (!child) {\n        return;\n      }\n      curr = child;\n    }\n    delete curr[1][this.mapper(path[path.length - 1])];\n  }\n}\n","import {VNode} from 'snabbdom';\nimport {EventDelegator} from './EventDelegator';\nimport {Scope} from './isolate';\nimport {isEqualNamespace} from './utils';\nimport SymbolTree from './SymbolTree';\n\nexport class IsolateModule {\n  private namespaceTree = new SymbolTree<Element, Scope>(x => x.scope);\n  private namespaceByElement: Map<Element, Array<Scope>>;\n  private eventDelegator: EventDelegator | undefined;\n\n  /**\n   * A registry that keeps track of all the nodes that are removed from\n   * the virtual DOM in a single patch. Those nodes are cleaned once snabbdom\n   * has finished patching the DOM.\n   */\n  private vnodesBeingRemoved: Array<VNode>;\n\n  constructor() {\n    this.namespaceByElement = new Map<Element, Array<Scope>>();\n    this.vnodesBeingRemoved = [];\n  }\n\n  public setEventDelegator(del: EventDelegator): void {\n    this.eventDelegator = del;\n  }\n\n  private insertElement(namespace: Array<Scope>, el: Element): void {\n    this.namespaceByElement.set(el, namespace);\n    this.namespaceTree.set(namespace, el);\n  }\n\n  private removeElement(elm: Element): void {\n    this.namespaceByElement.delete(elm);\n    const namespace = this.getNamespace(elm);\n    if (namespace) {\n      this.namespaceTree.delete(namespace);\n    }\n  }\n\n  public getElement(\n    namespace: Array<Scope>,\n    max?: number\n  ): Element | undefined {\n    return this.namespaceTree.get(namespace, undefined, max);\n  }\n\n  public getRootElement(elm: Element): Element | undefined {\n    if (this.namespaceByElement.has(elm)) {\n      return elm;\n    }\n\n    //TODO: Add quick-lru or similar as additional O(1) cache\n\n    let curr = elm;\n    while (!this.namespaceByElement.has(curr)) {\n      curr = curr.parentNode as Element;\n      if (!curr) {\n        return undefined;\n      } else if (curr.tagName === 'HTML') {\n        throw new Error('No root element found, this should not happen at all');\n      }\n    }\n    return curr;\n  }\n\n  public getNamespace(elm: Element): Array<Scope> | undefined {\n    const rootElement = this.getRootElement(elm);\n    if (!rootElement) {\n      return undefined;\n    }\n    return this.namespaceByElement.get(rootElement) as Array<Scope>;\n  }\n\n  public createModule() {\n    const self = this;\n    return {\n      create(emptyVNode: VNode, vNode: VNode) {\n        const {elm, data = {}} = vNode;\n        const namespace: Array<Scope> = (data as any).isolate;\n\n        if (Array.isArray(namespace)) {\n          self.insertElement(namespace, elm as Element);\n        }\n      },\n\n      update(oldVNode: VNode, vNode: VNode) {\n        const {elm: oldElm, data: oldData = {}} = oldVNode;\n        const {elm, data = {}} = vNode;\n        const oldNamespace: Array<Scope> = (oldData as any).isolate;\n        const namespace: Array<Scope> = (data as any).isolate;\n\n        if (!isEqualNamespace(oldNamespace, namespace)) {\n          if (Array.isArray(oldNamespace)) {\n            self.removeElement(oldElm as Element);\n          }\n        }\n        if (Array.isArray(namespace)) {\n          self.insertElement(namespace, elm as Element);\n        }\n      },\n\n      destroy(vNode: VNode) {\n        self.vnodesBeingRemoved.push(vNode);\n      },\n\n      remove(vNode: VNode, cb: Function) {\n        self.vnodesBeingRemoved.push(vNode);\n        cb();\n      },\n\n      post() {\n        const vnodesBeingRemoved = self.vnodesBeingRemoved;\n        for (let i = vnodesBeingRemoved.length - 1; i >= 0; i--) {\n          const vnode = vnodesBeingRemoved[i];\n          const namespace =\n            vnode.data !== undefined\n              ? (vnode.data as any).isolation\n              : undefined;\n          if (namespace !== undefined) {\n            self.removeElement(namespace);\n          }\n          (self.eventDelegator as EventDelegator).removeElement(\n            vnode.elm as Element,\n            namespace\n          );\n        }\n        self.vnodesBeingRemoved = [];\n      },\n    };\n  }\n}\n","export default class PriorityQueue<T> {\n  private arr: Array<T> = [];\n  private prios: Array<number> = [];\n\n  public add(t: T, prio: number): void {\n    for (let i = 0; i < this.arr.length; i++) {\n      if (this.prios[i] < prio) {\n        this.arr.splice(i, 0, t);\n        this.prios.splice(i, 0, prio);\n        return;\n      }\n    }\n    this.arr.push(t);\n    this.prios.push(prio);\n  }\n\n  public forEach(f: (t: T, i: number, arr: Array<T>) => void): void {\n    for (let i = 0; i < this.arr.length; i++) {\n      f(this.arr[i], i, this.arr);\n    }\n  }\n\n  public delete(t: T): void {\n    for (let i = 0; i < this.arr.length; i++) {\n      if (this.arr[i] === t) {\n        this.arr.splice(i, 1);\n        this.prios.splice(i, 1);\n        return;\n      }\n    }\n  }\n}\n","import xs, {Stream, Subscription} from 'xstream';\nimport {ScopeChecker} from './ScopeChecker';\nimport {IsolateModule} from './IsolateModule';\nimport {getSelectors, isEqualNamespace} from './utils';\nimport {ElementFinder} from './ElementFinder';\nimport {EventsFnOptions} from './DOMSource';\nimport {Scope} from './isolate';\nimport SymbolTree from './SymbolTree';\nimport PriorityQueue from './PriorityQueue';\nimport {\n  fromEvent,\n  preventDefaultConditional,\n  PreventDefaultOpt,\n} from './fromEvent';\n\ndeclare var requestIdleCallback: any;\n\ninterface Destination {\n  useCapture: boolean;\n  bubbles: boolean;\n  passive: boolean;\n  scopeChecker: ScopeChecker;\n  subject: Stream<Event>;\n  preventDefault?: PreventDefaultOpt;\n}\n\nexport interface CycleDOMEvent extends Event {\n  propagationHasBeenStopped: boolean;\n  ownerTarget: Element;\n}\n\nexport const eventTypesThatDontBubble = [\n  `blur`,\n  `canplay`,\n  `canplaythrough`,\n  `durationchange`,\n  `emptied`,\n  `ended`,\n  `focus`,\n  `load`,\n  `loadeddata`,\n  `loadedmetadata`,\n  `mouseenter`,\n  `mouseleave`,\n  `pause`,\n  `play`,\n  `playing`,\n  `ratechange`,\n  `reset`,\n  `scroll`,\n  `seeked`,\n  `seeking`,\n  `stalled`,\n  `submit`,\n  `suspend`,\n  `timeupdate`,\n  `unload`,\n  `volumechange`,\n  `waiting`,\n];\n\ninterface DOMListener {\n  sub: Subscription;\n  passive: boolean;\n}\n\ninterface NonBubblingListener {\n  sub: Subscription | undefined;\n  destination: Destination;\n}\n\ntype NonBubblingMeta = [Stream<Event>, string, ElementFinder, Destination]\n\n/**\n * Manages \"Event delegation\", by connecting an origin with multiple\n * destinations.\n *\n * Attaches a DOM event listener to the DOM element called the \"origin\",\n * and delegates events to \"destinations\", which are subjects as outputs\n * for the DOMSource. Simulates bubbling or capturing, with regards to\n * isolation boundaries too.\n */\nexport class EventDelegator {\n  private virtualListeners = new SymbolTree<\n    Map<string, PriorityQueue<Destination>>,\n    Scope\n  >(x => x.scope);\n  private origin: Element | undefined;\n\n  private domListeners: Map<string, DOMListener>;\n  private nonBubblingListeners: Map<string, Map<Element, NonBubblingListener>>;\n  private domListenersToAdd: Map<string, boolean>;\n  private nonBubblingListenersToAdd = new Set<NonBubblingMeta>();\n\n  private virtualNonBubblingListener: Array<Destination> = [];\n\n  constructor(\n    private rootElement$: Stream<Element>,\n    public isolateModule: IsolateModule\n  ) {\n    this.isolateModule.setEventDelegator(this);\n    this.domListeners = new Map<string, DOMListener>();\n    this.domListenersToAdd = new Map<string, boolean>();\n    this.nonBubblingListeners = new Map<\n      string,\n      Map<Element, NonBubblingListener>\n    >();\n    rootElement$.addListener({\n      next: (el: Element) => {\n        if (this.origin !== el) {\n          this.origin = el;\n          this.resetEventListeners();\n          this.domListenersToAdd.forEach((passive, type) =>\n            this.setupDOMListener(type, passive)\n          );\n          this.domListenersToAdd.clear();\n        }\n\n        this.nonBubblingListenersToAdd.forEach(arr => {\n          this.setupNonBubblingListener(arr);\n        });\n      },\n    });\n  }\n\n  public addEventListener(\n    eventType: string,\n    namespace: Array<Scope>,\n    options: EventsFnOptions,\n    bubbles?: boolean\n  ): Stream<Event> {\n    const subject = xs.never();\n    let dest;\n\n    const scopeChecker = new ScopeChecker(namespace, this.isolateModule);\n\n    const shouldBubble =\n      bubbles === undefined\n        ? eventTypesThatDontBubble.indexOf(eventType) === -1\n        : bubbles;\n\n    if (shouldBubble) {\n      if (!this.domListeners.has(eventType)) {\n        this.setupDOMListener(eventType, !!options.passive);\n      }\n\n      dest = this.insertListener(subject, scopeChecker, eventType, options);\n      return subject;\n    } else {\n      const setArray: Array<NonBubblingMeta> = [];\n      this.nonBubblingListenersToAdd.forEach(v => setArray.push(v));\n      let found = undefined, index = 0;\n      const length = setArray.length;\n      const tester = (x: NonBubblingMeta) => {\n        const [_sub, et, ef, _] = x;\n        return eventType === et && isEqualNamespace(ef.namespace, namespace);\n      }\n\n      while (!found && index < length) {\n        const item = setArray[index]\n        found = tester(item) ? item : found;\n        index++;\n      }\n\n      let input: NonBubblingMeta = found as NonBubblingMeta;\n\n      let nonBubbleSubject: Stream<Event>;\n      if (!input) {\n        const finder = new ElementFinder(namespace, this.isolateModule);\n        dest = this.insertListener(subject, scopeChecker, eventType, options);\n        input = [subject, eventType, finder, dest];\n        nonBubbleSubject = subject;\n        this.nonBubblingListenersToAdd.add(input);\n        this.setupNonBubblingListener(input);\n      } else {\n        const [sub] = input;\n        nonBubbleSubject = sub;\n      }\n\n      const self = this;\n\n      let subscription: any = null;\n      return xs.create({\n        start: listener => {\n          subscription = nonBubbleSubject.subscribe(listener);\n        },\n        stop: () => {\n          const [_s, et, ef, _d] = input;\n          const elements = ef.call();\n      \n          elements.forEach(function(element: any) {\n            const subs = element.subs;\n            if (subs && subs[et]) {\n              subs[et].unsubscribe();\n              delete subs[et];\n            }\n          });\n      \n          self.nonBubblingListenersToAdd.delete(input as any);\n      \n          subscription.unsubscribe();\n        }\n      });\n    }\n  }\n\n  public removeElement(element: Element, namespace?: Array<Scope>): void {\n    if (namespace !== undefined) {\n      this.virtualListeners.delete(namespace);\n    }\n    const toRemove: Array<[string, Element]> = [];\n    this.nonBubblingListeners.forEach((map, type) => {\n      if (map.has(element)) {\n        toRemove.push([type, element]);\n        const subs = (element as any).subs;\n        if (subs) {\n          Object.keys(subs).forEach((key: any) => {\n            subs[key].unsubscribe();\n          });\n        }\n      }\n    });\n    for (let i = 0; i < toRemove.length; i++) {\n      const map = this.nonBubblingListeners.get(toRemove[i][0]);\n      if (!map) {\n        continue;\n      }\n      map.delete(toRemove[i][1]);\n      if (map.size === 0) {\n        this.nonBubblingListeners.delete(toRemove[i][0]);\n      } else {\n        this.nonBubblingListeners.set(toRemove[i][0], map);\n      }\n    }\n  }\n\n  private insertListener(\n    subject: Stream<Event>,\n    scopeChecker: ScopeChecker,\n    eventType: string,\n    options: EventsFnOptions\n  ): Destination {\n    const relevantSets: Array<PriorityQueue<Destination>> = [];\n    const n = scopeChecker._namespace;\n    let max = n.length;\n\n    do {\n      relevantSets.push(this.getVirtualListeners(eventType, n, true, max));\n      max--;\n    } while (max >= 0 && n[max].type !== 'total');\n\n    const destination = {\n      ...options,\n      scopeChecker,\n      subject,\n      bubbles: !!options.bubbles,\n      useCapture: !!options.useCapture,\n      passive: !!options.passive,\n    };\n\n    for (let i = 0; i < relevantSets.length; i++) {\n      relevantSets[i].add(destination, n.length);\n    }\n\n    return destination;\n  }\n\n  /**\n   * Returns a set of all virtual listeners in the scope of the namespace\n   * Set `exact` to true to treat sibiling isolated scopes as total scopes\n   */\n  private getVirtualListeners(\n    eventType: string,\n    namespace: Array<Scope>,\n    exact = false,\n    max?: number\n  ): PriorityQueue<Destination> {\n    let _max = max !== undefined ? max : namespace.length;\n    if (!exact) {\n      for (let i = _max - 1; i >= 0; i--) {\n        if (namespace[i].type === 'total') {\n          _max = i + 1;\n          break;\n        }\n        _max = i;\n      }\n    }\n\n    const map = this.virtualListeners.getDefault(\n      namespace,\n      () => new Map<string, PriorityQueue<Destination>>(),\n      _max\n    );\n\n    if (!map.has(eventType)) {\n      map.set(eventType, new PriorityQueue<Destination>());\n    }\n    return map.get(eventType) as PriorityQueue<Destination>;\n  }\n\n  private setupDOMListener(eventType: string, passive: boolean): void {\n    if (this.origin) {\n      const sub = fromEvent(\n        this.origin,\n        eventType,\n        false,\n        false,\n        passive\n      ).subscribe({\n        next: (event: Event) => this.onEvent(eventType, event, passive),\n        error: () => {},\n        complete: () => {},\n      });\n      this.domListeners.set(eventType, {sub, passive});\n    } else {\n      this.domListenersToAdd.set(eventType, passive);\n    }\n  }\n\n  private setupNonBubblingListener(\n    input: NonBubblingMeta\n  ): void {\n    const [_, eventType, elementFinder, destination] = input;\n    if (!this.origin) {\n      return;\n    }\n\n    const elements = elementFinder.call();\n    if (elements.length) {\n      const self = this;\n      elements.forEach((element: Element) => {\n        const subs = (element as any).subs;\n        if (!subs || !subs[eventType]) {\n          const sub = fromEvent(\n            element,\n            eventType,\n            false,\n            false,\n            destination.passive\n          ).subscribe({\n            next: (ev: Event) =>\n              self.onEvent(eventType, ev, !!destination.passive, false),\n            error: () => {},\n            complete: () => {},\n          });\n          if (!self.nonBubblingListeners.has(eventType)) {\n            self.nonBubblingListeners.set(\n              eventType,\n              new Map<Element, NonBubblingListener>()\n            );\n          }\n          const map = self.nonBubblingListeners.get(eventType);\n          if (!map) {\n            return;\n          }\n          map.set(element, {sub, destination});\n\n          (element as any).subs = {\n            ...subs,\n            [eventType]: sub,\n          };\n        }\n      });\n    }\n  }\n\n  private resetEventListeners(): void {\n    const iter = this.domListeners.entries();\n    let curr = iter.next();\n    while (!curr.done) {\n      const [type, {sub, passive}] = curr.value;\n      sub.unsubscribe();\n      this.setupDOMListener(type, passive);\n      curr = iter.next();\n    }\n  }\n\n  private putNonBubblingListener(\n    eventType: string,\n    elm: Element,\n    useCapture: boolean,\n    passive: boolean\n  ): void {\n    const map = this.nonBubblingListeners.get(eventType);\n    if (!map) {\n      return;\n    }\n    const listener = map.get(elm);\n    if (\n      listener &&\n      listener.destination.passive === passive &&\n      listener.destination.useCapture === useCapture\n    ) {\n      this.virtualNonBubblingListener[0] = listener.destination;\n    }\n  }\n\n  private onEvent(\n    eventType: string,\n    event: Event,\n    passive: boolean,\n    bubbles = true\n  ): void {\n    const cycleEvent = this.patchEvent(event);\n    const rootElement = this.isolateModule.getRootElement(\n      event.target as Element\n    );\n\n    if (bubbles) {\n      const namespace = this.isolateModule.getNamespace(\n        event.target as Element\n      );\n      if (!namespace) {\n        return;\n      }\n      const listeners = this.getVirtualListeners(eventType, namespace);\n      this.bubble(\n        eventType,\n        event.target as Element,\n        rootElement,\n        cycleEvent,\n        listeners,\n        namespace,\n        namespace.length - 1,\n        true,\n        passive\n      );\n\n      this.bubble(\n        eventType,\n        event.target as Element,\n        rootElement,\n        cycleEvent,\n        listeners,\n        namespace,\n        namespace.length - 1,\n        false,\n        passive\n      );\n    } else {\n      this.putNonBubblingListener(\n        eventType,\n        event.target as Element,\n        true,\n        passive\n      );\n      this.doBubbleStep(\n        eventType,\n        event.target as Element,\n        rootElement,\n        cycleEvent,\n        this.virtualNonBubblingListener,\n        true,\n        passive\n      );\n\n      this.putNonBubblingListener(\n        eventType,\n        event.target as Element,\n        false,\n        passive\n      );\n      this.doBubbleStep(\n        eventType,\n        event.target as Element,\n        rootElement,\n        cycleEvent,\n        this.virtualNonBubblingListener,\n        false,\n        passive\n      );\n      event.stopPropagation(); //fix reset event (spec'ed as non-bubbling, but bubbles in reality\n    }\n  }\n\n  private bubble(\n    eventType: string,\n    elm: Element,\n    rootElement: Element | undefined,\n    event: CycleDOMEvent,\n    listeners: PriorityQueue<Destination>,\n    namespace: Array<Scope>,\n    index: number,\n    useCapture: boolean,\n    passive: boolean\n  ): void {\n    if (!useCapture && !event.propagationHasBeenStopped) {\n      this.doBubbleStep(\n        eventType,\n        elm,\n        rootElement,\n        event,\n        listeners,\n        useCapture,\n        passive\n      );\n    }\n\n    let newRoot: Element | undefined = rootElement;\n    let newIndex = index;\n    if (elm === rootElement) {\n      if (index >= 0 && namespace[index].type === 'sibling') {\n        newRoot = this.isolateModule.getElement(namespace, index);\n        newIndex--;\n      } else {\n        return;\n      }\n    }\n\n    if (elm.parentNode && newRoot) {\n      this.bubble(\n        eventType,\n        elm.parentNode as Element,\n        newRoot,\n        event,\n        listeners,\n        namespace,\n        newIndex,\n        useCapture,\n        passive\n      );\n    }\n\n    if (useCapture && !event.propagationHasBeenStopped) {\n      this.doBubbleStep(\n        eventType,\n        elm,\n        rootElement,\n        event,\n        listeners,\n        useCapture,\n        passive\n      );\n    }\n  }\n\n  private doBubbleStep(\n    eventType: string,\n    elm: Element,\n    rootElement: Element | undefined,\n    event: CycleDOMEvent,\n    listeners: PriorityQueue<Destination> | Array<Destination>,\n    useCapture: boolean,\n    passive: boolean\n  ): void {\n    if (!rootElement) {\n      return;\n    }\n    this.mutateEventCurrentTarget(event, elm);\n    listeners.forEach(dest => {\n      if (dest.passive === passive && dest.useCapture === useCapture) {\n        const sel = getSelectors(dest.scopeChecker.namespace);\n        if (\n          !event.propagationHasBeenStopped &&\n          dest.scopeChecker.isDirectlyInScope(elm) &&\n          ((sel !== '' && elm.matches(sel)) ||\n            (sel === '' && elm === rootElement))\n        ) {\n          preventDefaultConditional(\n            event,\n            dest.preventDefault as PreventDefaultOpt\n          );\n\n          dest.subject.shamefullySendNext(event);\n        }\n      }\n    });\n  }\n\n  private patchEvent(event: Event): CycleDOMEvent {\n    const pEvent = event as CycleDOMEvent;\n    pEvent.propagationHasBeenStopped = false;\n    const oldStopPropagation = pEvent.stopPropagation;\n    pEvent.stopPropagation = function stopPropagation() {\n      oldStopPropagation.call(this);\n      this.propagationHasBeenStopped = true;\n    };\n    return pEvent;\n  }\n\n  private mutateEventCurrentTarget(\n    event: CycleDOMEvent,\n    currentTargetElement: Element\n  ) {\n    try {\n      Object.defineProperty(event, `currentTarget`, {\n        value: currentTargetElement,\n        configurable: true,\n      });\n    } catch (err) {\n      console.log(`please use event.ownerTarget`);\n    }\n    event.ownerTarget = currentTargetElement;\n  }\n}\n","import {Driver, FantasyObservable} from '@cycle/run';\nimport {init, Module, Options as SnabbdomOptions, VNode, toVNode} from 'snabbdom';\nimport xs, {Stream, Listener} from 'xstream';\nimport concat from 'xstream/extra/concat';\nimport sampleCombine from 'xstream/extra/sampleCombine';\nimport {DOMSource} from './DOMSource';\nimport {MainDOMSource} from './MainDOMSource';\nimport {VNodeWrapper} from './VNodeWrapper';\nimport {getValidNode, checkValidContainer} from './utils';\nimport defaultModules from './modules';\nimport {IsolateModule} from './IsolateModule';\nimport {EventDelegator} from './EventDelegator';\n\nfunction makeDOMDriverInputGuard(modules: any) {\n  if (!Array.isArray(modules)) {\n    throw new Error(\n      `Optional modules option must be an array for snabbdom modules`\n    );\n  }\n}\n\nfunction domDriverInputGuard(view$: Stream<VNode>): void {\n  if (\n    !view$ ||\n    typeof view$.addListener !== `function` ||\n    typeof view$.fold !== `function`\n  ) {\n    throw new Error(\n      `The DOM driver function expects as input a Stream of ` +\n        `virtual DOM elements`\n    );\n  }\n}\n\nexport interface DOMDriverOptions {\n  modules?: Array<Partial<Module>>;\n  reportSnabbdomError?(err: any): void;\n  snabbdomOptions?: SnabbdomOptions;\n}\n\nfunction dropCompletion<T>(input: Stream<T>): Stream<T> {\n  return xs.merge(input, xs.never());\n}\n\nfunction unwrapElementFromVNode(vnode: VNode): Element {\n  return vnode.elm as Element;\n}\n\nfunction defaultReportSnabbdomError(err: any): void {\n  (console.error || console.log)(err);\n}\n\nfunction makeDOMReady$(): Stream<null> {\n  return xs.create<null>({\n    start(lis: Listener<null>) {\n      if (document.readyState === 'loading') {\n        document.addEventListener('readystatechange', () => {\n          const state = document.readyState;\n          if (state === 'interactive' || state === 'complete') {\n            lis.next(null);\n            lis.complete();\n          }\n        });\n      } else {\n        lis.next(null);\n        lis.complete();\n      }\n    },\n    stop() {},\n  });\n}\n\nfunction addRootScope(vnode: VNode): VNode {\n  vnode.data = vnode.data || {};\n  vnode.data.isolate = [];\n  return vnode;\n}\n\nfunction makeDOMDriver(\n  container: string | Element | DocumentFragment,\n  options: DOMDriverOptions = {}\n): Driver<Stream<VNode>, MainDOMSource> {\n  checkValidContainer(container);\n  const modules = options.modules || defaultModules;\n  makeDOMDriverInputGuard(modules);\n  const isolateModule = new IsolateModule();\n  const snabbdomOptions = options && options.snabbdomOptions || undefined;\n  const patch = init([isolateModule.createModule() as Partial<Module>].concat(modules), undefined, snabbdomOptions);\n  const domReady$ = makeDOMReady$();\n  let vnodeWrapper: VNodeWrapper;\n  let mutationObserver: MutationObserver;\n  const mutationConfirmed$ = xs.create<null>({\n    start(listener) {\n      mutationObserver = new MutationObserver(() => listener.next(null));\n    },\n    stop() {\n      mutationObserver.disconnect();\n    },\n  });\n\n  function DOMDriver(vnode$: Stream<VNode>, name = 'DOM'): MainDOMSource {\n    domDriverInputGuard(vnode$);\n    const sanitation$ = xs.create<null>();\n\n    const firstRoot$ = domReady$.map(() => {\n      const firstRoot = getValidNode(container) || document.body;\n      vnodeWrapper = new VNodeWrapper(firstRoot);\n      return firstRoot;\n    });\n\n    // We need to subscribe to the sink (i.e. vnode$) synchronously inside this\n    // driver, and not later in the map().flatten() because this sink is in\n    // reality a SinkProxy from @cycle/run, and we don't want to miss the first\n    // emission when the main() is connected to the drivers.\n    // Read more in issue #739.\n    const rememberedVNode$ = vnode$.remember();\n    rememberedVNode$.addListener({});\n\n    // The mutation observer internal to mutationConfirmed$ should\n    // exist before elementAfterPatch$ calls mutationObserver.observe()\n    mutationConfirmed$.addListener({});\n\n    const elementAfterPatch$ = firstRoot$\n      .map(\n        firstRoot =>\n          xs\n            .merge(rememberedVNode$.endWhen(sanitation$), sanitation$)\n            .map(vnode => vnodeWrapper.call(vnode))\n            .startWith(addRootScope(toVNode(firstRoot)))\n            .fold(patch, toVNode(firstRoot))\n            .drop(1)\n            .map(unwrapElementFromVNode)\n            .startWith(firstRoot as any)\n            .map(el => {\n              mutationObserver.observe(el, {\n                childList: true,\n                attributes: true,\n                characterData: true,\n                subtree: true,\n                attributeOldValue: true,\n                characterDataOldValue: true,\n              });\n              return el;\n            })\n            .compose(dropCompletion) // don't complete this stream\n      )\n      .flatten();\n\n    const rootElement$ = concat(domReady$, mutationConfirmed$)\n      .endWhen(sanitation$)\n      .compose(sampleCombine(elementAfterPatch$))\n      .map(arr => arr[1])\n      .remember();\n\n    // Start the snabbdom patching, over time\n    rootElement$.addListener({\n      error: options.reportSnabbdomError || defaultReportSnabbdomError,\n    });\n\n    const delegator = new EventDelegator(rootElement$, isolateModule);\n\n    return new MainDOMSource(\n      rootElement$,\n      sanitation$,\n      [],\n      isolateModule,\n      delegator,\n      name\n    );\n  }\n\n  return DOMDriver as any;\n}\n\nexport {makeDOMDriver};\n","import xs, {Stream, MemoryStream} from 'xstream';\nimport {DevToolEnabledSource, FantasyObservable} from '@cycle/run';\nimport {VNode} from 'snabbdom';\nimport {DOMSource, EventsFnOptions} from './DOMSource';\nimport {adapt} from '@cycle/run/lib/adapt';\n\nexport type MockConfig = {\n  [name: string]: FantasyObservable<any> | MockConfig;\n};\n\nconst SCOPE_PREFIX = '___';\n\nexport class MockedDOMSource {\n  private _elements: FantasyObservable<any>;\n\n  constructor(private _mockConfig: MockConfig) {\n    if (_mockConfig.elements) {\n      this._elements = _mockConfig.elements as FantasyObservable<any>;\n    } else {\n      this._elements = adapt(xs.empty());\n    }\n  }\n\n  public elements(): any {\n    const out: Partial<DevToolEnabledSource> & FantasyObservable<any> = this\n      ._elements;\n    out._isCycleSource = 'MockedDOM';\n    return out;\n  }\n\n  public element(): any {\n    const output$: MemoryStream<Element> = this.elements()\n      .filter((arr: Array<any>) => arr.length > 0)\n      .map((arr: Array<any>) => arr[0])\n      .remember();\n    const out: DevToolEnabledSource & MemoryStream<Element> = adapt(output$);\n    out._isCycleSource = 'MockedDOM';\n    return out;\n  }\n\n  public events(\n    eventType: string,\n    options?: EventsFnOptions,\n    bubbles?: boolean\n  ): any {\n    const streamForEventType = this._mockConfig[eventType] as any;\n    const out: DevToolEnabledSource & FantasyObservable<any> = adapt(\n      streamForEventType || xs.empty()\n    );\n\n    out._isCycleSource = 'MockedDOM';\n\n    return out;\n  }\n\n  public select(selector: string): MockedDOMSource {\n    const mockConfigForSelector = this._mockConfig[selector] || {};\n\n    return new MockedDOMSource(mockConfigForSelector as MockConfig);\n  }\n\n  public isolateSource(\n    source: MockedDOMSource,\n    scope: string\n  ): MockedDOMSource {\n    return source.select('.' + SCOPE_PREFIX + scope);\n  }\n\n  public isolateSink(sink: any, scope: string): any {\n    return adapt(\n      xs.fromObservable<any>(sink).map((vnode: VNode) => {\n        if (vnode.sel && vnode.sel.indexOf(SCOPE_PREFIX + scope) !== -1) {\n          return vnode;\n        } else {\n          vnode.sel += `.${SCOPE_PREFIX}${scope}`;\n          return vnode;\n        }\n      })\n    );\n  }\n}\n\nexport function mockDOMSource(mockConfig: MockConfig): MockedDOMSource {\n  return new MockedDOMSource(mockConfig);\n}\n","// tslint:disable:max-file-line-count\nimport {h, VNode, VNodeData} from 'snabbdom';\n\nfunction isValidString(param: any): boolean {\n  return typeof param === 'string' && param.length > 0;\n}\n\nfunction isSelector(param: any): boolean {\n  return isValidString(param) && (param[0] === '.' || param[0] === '#');\n}\n\nfunction createTagFunction(tagName: string): Function {\n  return function hyperscript(a: any, b?: any, c?: any): VNode {\n    const hasA = typeof a !== 'undefined';\n    const hasB = typeof b !== 'undefined';\n    const hasC = typeof c !== 'undefined';\n    if (isSelector(a)) {\n      if (hasB && hasC) {\n        return h(tagName + a, b, c);\n      } else if (hasB) {\n        return h(tagName + a, b);\n      } else {\n        return h(tagName + a, {});\n      }\n    } else if (hasC) {\n      return h(tagName + a, b, c);\n    } else if (hasB) {\n      return h(tagName, a, b);\n    } else if (hasA) {\n      return h(tagName, a);\n    } else {\n      return h(tagName, {});\n    }\n  };\n}\n\nconst SVG_TAG_NAMES = [\n  'a',\n  'altGlyph',\n  'altGlyphDef',\n  'altGlyphItem',\n  'animate',\n  'animateColor',\n  'animateMotion',\n  'animateTransform',\n  'circle',\n  'clipPath',\n  'colorProfile',\n  'cursor',\n  'defs',\n  'desc',\n  'ellipse',\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotlight',\n  'feTile',\n  'feTurbulence',\n  'filter',\n  'font',\n  'fontFace',\n  'fontFaceFormat',\n  'fontFaceName',\n  'fontFaceSrc',\n  'fontFaceUri',\n  'foreignObject',\n  'g',\n  'glyph',\n  'glyphRef',\n  'hkern',\n  'image',\n  'line',\n  'linearGradient',\n  'marker',\n  'mask',\n  'metadata',\n  'missingGlyph',\n  'mpath',\n  'path',\n  'pattern',\n  'polygon',\n  'polyline',\n  'radialGradient',\n  'rect',\n  'script',\n  'set',\n  'stop',\n  'style',\n  'switch',\n  'symbol',\n  'text',\n  'textPath',\n  'title',\n  'tref',\n  'tspan',\n  'use',\n  'view',\n  'vkern',\n];\n\nconst svg = createTagFunction('svg');\n\nSVG_TAG_NAMES.forEach(tag => {\n  svg[tag] = createTagFunction(tag);\n});\n\nconst TAG_NAMES = [\n  'a',\n  'abbr',\n  'address',\n  'area',\n  'article',\n  'aside',\n  'audio',\n  'b',\n  'base',\n  'bdi',\n  'bdo',\n  'blockquote',\n  'body',\n  'br',\n  'button',\n  'canvas',\n  'caption',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'dd',\n  'del',\n  'details',\n  'dfn',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'em',\n  'embed',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'i',\n  'iframe',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'keygen',\n  'label',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'map',\n  'mark',\n  'menu',\n  'meta',\n  'nav',\n  'noscript',\n  'object',\n  'ol',\n  'optgroup',\n  'option',\n  'p',\n  'param',\n  'pre',\n  'progress',\n  'q',\n  'rp',\n  'rt',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'section',\n  'select',\n  'small',\n  'source',\n  'span',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'table',\n  'tbody',\n  'td',\n  'textarea',\n  'tfoot',\n  'th',\n  'thead',\n  'time',\n  'title',\n  'tr',\n  'u',\n  'ul',\n  'video',\n];\n\nconst exported = {\n  SVG_TAG_NAMES,\n  TAG_NAMES,\n  svg,\n  isSelector,\n  createTagFunction,\n};\nTAG_NAMES.forEach(n => {\n  exported[n] = createTagFunction(n);\n});\nexport default (exported as any) as HyperScriptHelpers;\n\nexport type Children = Array<VNode | string | null>;\nexport type Properties = any; //VNodeData // does not work yet, because of https://github.com/snabbdom/snabbdom/pull/325\nexport interface HyperScriptHelperFn {\n  (): VNode;\n  (textOrSelector: string): VNode;\n  (children: Children): VNode;\n  (properties: Properties): VNode;\n  (selector: string, children: Children): VNode;\n  (selector: string, text: string): VNode;\n  (selector: string, properties: Properties): VNode;\n  (properties: Properties, children: Children): VNode;\n  (properties: Properties, text: string): VNode;\n  (selector: string, properties: Properties, text: string): VNode;\n  (selector: string, properties: Properties, children: Children): VNode;\n}\n\nexport interface SVGHelperFn extends HyperScriptHelperFn {\n  a: HyperScriptHelperFn;\n  altGlyph: HyperScriptHelperFn;\n  altGlyphDef: HyperScriptHelperFn;\n  altGlyphItem: HyperScriptHelperFn;\n  animate: HyperScriptHelperFn;\n  animateColor: HyperScriptHelperFn;\n  animateMotion: HyperScriptHelperFn;\n  animateTransform: HyperScriptHelperFn;\n  circle: HyperScriptHelperFn;\n  clipPath: HyperScriptHelperFn;\n  colorProfile: HyperScriptHelperFn;\n  cursor: HyperScriptHelperFn;\n  defs: HyperScriptHelperFn;\n  desc: HyperScriptHelperFn;\n  ellipse: HyperScriptHelperFn;\n  feBlend: HyperScriptHelperFn;\n  feColorMatrix: HyperScriptHelperFn;\n  feComponentTransfer: HyperScriptHelperFn;\n  feComposite: HyperScriptHelperFn;\n  feConvolveMatrix: HyperScriptHelperFn;\n  feDiffuseLighting: HyperScriptHelperFn;\n  feDisplacementMap: HyperScriptHelperFn;\n  feDistantLight: HyperScriptHelperFn;\n  feFlood: HyperScriptHelperFn;\n  feFuncA: HyperScriptHelperFn;\n  feFuncB: HyperScriptHelperFn;\n  feFuncG: HyperScriptHelperFn;\n  feFuncR: HyperScriptHelperFn;\n  feGaussianBlur: HyperScriptHelperFn;\n  feImage: HyperScriptHelperFn;\n  feMerge: HyperScriptHelperFn;\n  feMergeNode: HyperScriptHelperFn;\n  feMorphology: HyperScriptHelperFn;\n  feOffset: HyperScriptHelperFn;\n  fePointLight: HyperScriptHelperFn;\n  feSpecularLighting: HyperScriptHelperFn;\n  feSpotlight: HyperScriptHelperFn;\n  feTile: HyperScriptHelperFn;\n  feTurbulence: HyperScriptHelperFn;\n  filter: HyperScriptHelperFn;\n  font: HyperScriptHelperFn;\n  fontFace: HyperScriptHelperFn;\n  fontFaceFormat: HyperScriptHelperFn;\n  fontFaceName: HyperScriptHelperFn;\n  fontFaceSrc: HyperScriptHelperFn;\n  fontFaceUri: HyperScriptHelperFn;\n  foreignObject: HyperScriptHelperFn;\n  g: HyperScriptHelperFn;\n  glyph: HyperScriptHelperFn;\n  glyphRef: HyperScriptHelperFn;\n  hkern: HyperScriptHelperFn;\n  image: HyperScriptHelperFn;\n  line: HyperScriptHelperFn;\n  linearGradient: HyperScriptHelperFn;\n  marker: HyperScriptHelperFn;\n  mask: HyperScriptHelperFn;\n  metadata: HyperScriptHelperFn;\n  missingGlyph: HyperScriptHelperFn;\n  mpath: HyperScriptHelperFn;\n  path: HyperScriptHelperFn;\n  pattern: HyperScriptHelperFn;\n  polygon: HyperScriptHelperFn;\n  polyline: HyperScriptHelperFn;\n  radialGradient: HyperScriptHelperFn;\n  rect: HyperScriptHelperFn;\n  script: HyperScriptHelperFn;\n  set: HyperScriptHelperFn;\n  stop: HyperScriptHelperFn;\n  style: HyperScriptHelperFn;\n  switch: HyperScriptHelperFn;\n  symbol: HyperScriptHelperFn;\n  text: HyperScriptHelperFn;\n  textPath: HyperScriptHelperFn;\n  title: HyperScriptHelperFn;\n  tref: HyperScriptHelperFn;\n  tspan: HyperScriptHelperFn;\n  use: HyperScriptHelperFn;\n  view: HyperScriptHelperFn;\n  vkern: HyperScriptHelperFn;\n}\n\nexport interface HyperScriptHelpers {\n  svg: SVGHelperFn;\n  a: HyperScriptHelperFn;\n  abbr: HyperScriptHelperFn;\n  address: HyperScriptHelperFn;\n  area: HyperScriptHelperFn;\n  article: HyperScriptHelperFn;\n  aside: HyperScriptHelperFn;\n  audio: HyperScriptHelperFn;\n  b: HyperScriptHelperFn;\n  base: HyperScriptHelperFn;\n  bdi: HyperScriptHelperFn;\n  bdo: HyperScriptHelperFn;\n  blockquote: HyperScriptHelperFn;\n  body: HyperScriptHelperFn;\n  br: HyperScriptHelperFn;\n  button: HyperScriptHelperFn;\n  canvas: HyperScriptHelperFn;\n  caption: HyperScriptHelperFn;\n  cite: HyperScriptHelperFn;\n  code: HyperScriptHelperFn;\n  col: HyperScriptHelperFn;\n  colgroup: HyperScriptHelperFn;\n  dd: HyperScriptHelperFn;\n  del: HyperScriptHelperFn;\n  details: HyperScriptHelperFn;\n  dfn: HyperScriptHelperFn;\n  dir: HyperScriptHelperFn;\n  div: HyperScriptHelperFn;\n  dl: HyperScriptHelperFn;\n  dt: HyperScriptHelperFn;\n  em: HyperScriptHelperFn;\n  embed: HyperScriptHelperFn;\n  fieldset: HyperScriptHelperFn;\n  figcaption: HyperScriptHelperFn;\n  figure: HyperScriptHelperFn;\n  footer: HyperScriptHelperFn;\n  form: HyperScriptHelperFn;\n  h1: HyperScriptHelperFn;\n  h2: HyperScriptHelperFn;\n  h3: HyperScriptHelperFn;\n  h4: HyperScriptHelperFn;\n  h5: HyperScriptHelperFn;\n  h6: HyperScriptHelperFn;\n  head: HyperScriptHelperFn;\n  header: HyperScriptHelperFn;\n  hgroup: HyperScriptHelperFn;\n  hr: HyperScriptHelperFn;\n  html: HyperScriptHelperFn;\n  i: HyperScriptHelperFn;\n  iframe: HyperScriptHelperFn;\n  img: HyperScriptHelperFn;\n  input: HyperScriptHelperFn;\n  ins: HyperScriptHelperFn;\n  kbd: HyperScriptHelperFn;\n  keygen: HyperScriptHelperFn;\n  label: HyperScriptHelperFn;\n  legend: HyperScriptHelperFn;\n  li: HyperScriptHelperFn;\n  link: HyperScriptHelperFn;\n  main: HyperScriptHelperFn;\n  map: HyperScriptHelperFn;\n  mark: HyperScriptHelperFn;\n  menu: HyperScriptHelperFn;\n  meta: HyperScriptHelperFn;\n  nav: HyperScriptHelperFn;\n  noscript: HyperScriptHelperFn;\n  object: HyperScriptHelperFn;\n  ol: HyperScriptHelperFn;\n  optgroup: HyperScriptHelperFn;\n  option: HyperScriptHelperFn;\n  p: HyperScriptHelperFn;\n  param: HyperScriptHelperFn;\n  pre: HyperScriptHelperFn;\n  progress: HyperScriptHelperFn;\n  q: HyperScriptHelperFn;\n  rp: HyperScriptHelperFn;\n  rt: HyperScriptHelperFn;\n  ruby: HyperScriptHelperFn;\n  s: HyperScriptHelperFn;\n  samp: HyperScriptHelperFn;\n  script: HyperScriptHelperFn;\n  section: HyperScriptHelperFn;\n  select: HyperScriptHelperFn;\n  small: HyperScriptHelperFn;\n  source: HyperScriptHelperFn;\n  span: HyperScriptHelperFn;\n  strong: HyperScriptHelperFn;\n  style: HyperScriptHelperFn;\n  sub: HyperScriptHelperFn;\n  summary: HyperScriptHelperFn;\n  sup: HyperScriptHelperFn;\n  table: HyperScriptHelperFn;\n  tbody: HyperScriptHelperFn;\n  td: HyperScriptHelperFn;\n  textarea: HyperScriptHelperFn;\n  tfoot: HyperScriptHelperFn;\n  th: HyperScriptHelperFn;\n  thead: HyperScriptHelperFn;\n  time: HyperScriptHelperFn;\n  title: HyperScriptHelperFn;\n  tr: HyperScriptHelperFn;\n  u: HyperScriptHelperFn;\n  ul: HyperScriptHelperFn;\n  video: HyperScriptHelperFn;\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n",null,"import xs, {Stream} from 'xstream';\nimport quicktask from 'quicktask';\nimport {adapt} from './adapt';\nimport {\n  DevToolEnabledSource,\n  DisposeFunction,\n  Drivers,\n  SinkProxies,\n  Sources,\n} from './types';\n\nexport function makeSinkProxies<D extends Drivers>(drivers: D): SinkProxies<D> {\n  const sinkProxies: SinkProxies<D> = {} as SinkProxies<D>;\n  for (const name in drivers) {\n    if (drivers.hasOwnProperty(name)) {\n      sinkProxies[name] = xs.create<any>();\n    }\n  }\n  return sinkProxies;\n}\n\nexport function callDrivers<D extends Drivers>(\n  drivers: D,\n  sinkProxies: SinkProxies<D>\n): Sources<D> {\n  const sources: Sources<D> = {} as Sources<D>;\n  for (const name in drivers) {\n    if (drivers.hasOwnProperty(name)) {\n      sources[name as any] = (drivers[name] as any)(sinkProxies[name], name);\n      if (sources[name as any] && typeof sources[name as any] === 'object') {\n        (sources[name as any] as DevToolEnabledSource)._isCycleSource = name;\n      }\n    }\n  }\n  return sources;\n}\n\n// NOTE: this will mutate `sources`.\nexport function adaptSources<So>(sources: So): So {\n  for (const name in sources) {\n    if (\n      sources.hasOwnProperty(name) &&\n      sources[name] &&\n      typeof ((sources[name] as any) as Stream<any>).shamefullySendNext ===\n        'function'\n    ) {\n      sources[name] = adapt((sources[name] as any) as Stream<any>);\n    }\n  }\n  return sources;\n}\n\n/**\n * Notice that we do not replicate 'complete' from real sinks, in\n * SinksReplicators and ReplicationBuffers.\n * Complete is triggered only on disposeReplication. See discussion in #425\n * for details.\n */\ntype SinkReplicators<Si> = {\n  [P in keyof Si]: {\n    next(x: any): void;\n    _n?(x: any): void;\n    error(err: any): void;\n    _e?(err: any): void;\n    complete(): void;\n  };\n};\n\ntype ReplicationBuffers<Si> = {\n  [P in keyof Si]: {\n    _n: Array<any>;\n    _e: Array<any>;\n  };\n};\n\nexport function replicateMany<Si extends any>(\n  sinks: Si,\n  sinkProxies: SinkProxies<Si>\n): DisposeFunction {\n  const scheduleMicrotask = quicktask();\n\n  const sinkNames: Array<keyof Si> = Object.keys(sinks).filter(\n    name => !!sinkProxies[name]\n  );\n\n  let buffers: ReplicationBuffers<Si> = {} as ReplicationBuffers<Si>;\n  const replicators: SinkReplicators<Si> = {} as SinkReplicators<Si>;\n  sinkNames.forEach(name => {\n    buffers[name] = {_n: [], _e: []};\n    replicators[name] = {\n      next: (x: any) => buffers[name]._n.push(x),\n      error: (err: any) => buffers[name]._e.push(err),\n      complete: () => {},\n    };\n  });\n\n  const subscriptions = sinkNames.map(name =>\n    xs.fromObservable(sinks[name] as any).subscribe(replicators[name])\n  );\n\n  sinkNames.forEach(name => {\n    const listener = sinkProxies[name];\n    const next = (x: any) => {\n      scheduleMicrotask(() => listener._n(x));\n    };\n    const error = (err: any) => {\n      scheduleMicrotask(() => {\n        (console.error || console.log)(err);\n        listener._e(err);\n      });\n    };\n    buffers[name]._n.forEach(next);\n    buffers[name]._e.forEach(error);\n    replicators[name].next = next;\n    replicators[name].error = error;\n    // because sink.subscribe(replicator) had mutated replicator to add\n    // _n, _e, _c, we must also update these:\n    replicators[name]._n = next;\n    replicators[name]._e = error;\n  });\n  buffers = null as any; // free up for GC\n\n  return function disposeReplication() {\n    subscriptions.forEach(s => s.unsubscribe());\n  };\n}\n\nexport function disposeSinkProxies<Si>(sinkProxies: SinkProxies<Si>) {\n  Object.keys(sinkProxies).forEach(name => sinkProxies[name]._c());\n}\n\nexport function disposeSources<So>(sources: So) {\n  for (const k in sources) {\n    if (\n      sources.hasOwnProperty(k) &&\n      sources[k] &&\n      (sources[k] as any).dispose\n    ) {\n      (sources[k] as any).dispose();\n    }\n  }\n}\n\nexport function isObjectEmpty(obj: any): boolean {\n  return Object.keys(obj).length === 0;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @function writeToStore\n * @description\n * A universal write function for localStorage and sessionStorage.\n * @param {object} request - the storage request object\n * @param {string} request.target - a string determines which storage to use\n * @param {string} request.action - a string determines the write action\n * @param {string} request.key - the key of a storage item\n * @param {string} request.value - the value of a storage item\n */\nfunction writeToStore(request) {\n    var _a = request.target, target = _a === void 0 ? 'local' : _a, _b = request.action, action = _b === void 0 ? 'setItem' : _b;\n    var key = request.key;\n    var value = request.value;\n    // Determine the storage target.\n    var storage = target === \"local\" ? localStorage : sessionStorage;\n    // Execute the storage action and pass arguments if they were defined.\n    storage[action](key, value);\n}\nexports.default = writeToStore;\n","import {Operator, Stream} from '../index';\nconst empty = {};\n\nexport class DropRepeatsOperator<T> implements Operator<T, T> {\n  public type = 'dropRepeats';\n  public out: Stream<T> = null as any;\n  public isEq: (x: T, y: T) => boolean;\n  private v: T = <any> empty;\n\n  constructor(public ins: Stream<T>,\n              fn: ((x: T, y: T) => boolean) | undefined) {\n    this.isEq = fn ? fn : (x, y) => x === y;\n  }\n\n  _start(out: Stream<T>): void {\n    this.out = out;\n    this.ins._add(this);\n  }\n\n  _stop(): void {\n    this.ins._remove(this);\n    this.out = null as any;\n    this.v = empty as any;\n  }\n\n  _n(t: T) {\n    const u = this.out;\n    if (!u) return;\n    const v = this.v;\n    if (v !== empty && this.isEq(t, v)) return;\n    this.v = t;\n    u._n(t);\n  }\n\n  _e(err: any) {\n    const u = this.out;\n    if (!u) return;\n    u._e(err);\n  }\n\n  _c() {\n    const u = this.out;\n    if (!u) return;\n    u._c();\n  }\n}\n\n/**\n * Drops consecutive duplicate values in a stream.\n *\n * Marble diagram:\n *\n * ```text\n * --1--2--1--1--1--2--3--4--3--3|\n *     dropRepeats\n * --1--2--1--------2--3--4--3---|\n * ```\n *\n * Example:\n *\n * ```js\n * import dropRepeats from 'xstream/extra/dropRepeats'\n *\n * const stream = xs.of(1, 2, 1, 1, 1, 2, 3, 4, 3, 3)\n *   .compose(dropRepeats())\n *\n * stream.addListener({\n *   next: i => console.log(i),\n *   error: err => console.error(err),\n *   complete: () => console.log('completed')\n * })\n * ```\n *\n * ```text\n * > 1\n * > 2\n * > 1\n * > 2\n * > 3\n * > 4\n * > 3\n * > completed\n * ```\n *\n * Example with a custom isEqual function:\n *\n * ```js\n * import dropRepeats from 'xstream/extra/dropRepeats'\n *\n * const stream = xs.of('a', 'b', 'a', 'A', 'B', 'b')\n *   .compose(dropRepeats((x, y) => x.toLowerCase() === y.toLowerCase()))\n *\n * stream.addListener({\n *   next: i => console.log(i),\n *   error: err => console.error(err),\n *   complete: () => console.log('completed')\n * })\n * ```\n *\n * ```text\n * > a\n * > b\n * > a\n * > B\n * > completed\n * ```\n *\n * @param {Function} isEqual An optional function of type\n * `(x: T, y: T) => boolean` that takes an event from the input stream and\n * checks if it is equal to previous event, by returning a boolean.\n * @return {Stream}\n */\nexport default function dropRepeats<T>(isEqual: ((x: T, y: T) => boolean) | undefined = void 0): (ins: Stream<T>) => Stream<T> {\n  return function dropRepeatsOperator(ins: Stream<T>): Stream<T> {\n    return new Stream<T>(new DropRepeatsOperator<T>(ins, isEqual));\n  };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar xstream_1 = require(\"xstream\");\nvar dropRepeats_1 = require(\"xstream/extra/dropRepeats\");\nvar adapt_1 = require(\"@cycle/run/lib/adapt\");\nvar extStorageProducer = {\n    start: function (listener) {\n        this.sendReq = function (storage) {\n            listener.next({\n                target: 'local',\n                key: storage.key,\n                value: storage.newValue\n            });\n        };\n        window.addEventListener('storage', this.sendReq);\n    },\n    stop: function () {\n        window.removeEventListener('storage', this.sendReq);\n    }\n};\nvar extStorage$ = typeof window !== \"undefined\"\n    ? xstream_1.default.create(extStorageProducer)\n    : xstream_1.default.never();\nfunction getStorage$(request$, type) {\n    if (type === 'local') {\n        return xstream_1.default.merge(request$.filter(function (req) { return !req.target || req.target === 'local'; }), extStorage$);\n    }\n    else {\n        return request$.filter(function (req) { return req.target === 'session'; });\n    }\n}\nfunction storageKey(n, request$, type) {\n    if (type === void 0) { type = 'local'; }\n    var storage$ = getStorage$(request$, type);\n    var key = type === \"local\" ? localStorage.key(n) : sessionStorage.key(n);\n    return storage$\n        .filter(function (req) { return req.key === key; })\n        .map(function (req) { return req.key; })\n        .startWith(key)\n        .compose(dropRepeats_1.default());\n}\nfunction storageGetItem(key, request$, type) {\n    if (type === void 0) { type = 'local'; }\n    var storage$ = getStorage$(request$, type);\n    var storageObj = type === \"local\" ? localStorage : sessionStorage;\n    return storage$\n        .filter(function (req) { return req.key === key; })\n        .map(function (req) { return req.value; })\n        .startWith(storageObj.getItem(key));\n}\nfunction getResponseObj(request$, type) {\n    if (type === void 0) { type = 'local'; }\n    return {\n        // Function returning stream of the nth key.\n        key: function (n) {\n            return adapt_1.adapt(storageKey(n, request$, type));\n        },\n        // Function returning stream of item values.\n        getItem: function (key) {\n            return adapt_1.adapt(storageGetItem(key, request$, type));\n        },\n    };\n}\nexports.default = getResponseObj;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nfunction default_1(request$) {\n    return {\n        // For localStorage.\n        get local() {\n            return util_1.default(request$);\n        },\n        // For sessionStorage.\n        get session() {\n            return util_1.default(request$, 'session');\n        },\n    };\n}\nexports.default = default_1;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar writeToStore_1 = require(\"./writeToStore\");\nvar responseCollection_1 = require(\"./responseCollection\");\n/**\n * Storage Driver.\n *\n * This is a localStorage and sessionStorage Driver for Cycle.js apps. The\n * driver is also a function, and it takes a stream of requests as input, and\n * returns a **`responseCollection`** with functions that allow reading from the\n * storage objects. The functions on the **`responseCollection`** return streams\n * of the storage data that was requested.\n *\n * **Requests**. The stream of requests should emit objects. These should be\n * instructions to write to the desired Storage object. Here are the `request`\n * object properties:\n *\n * - `target` *(String)*: type of storage, can be `local` or `session`, defaults\n * to `local`.\n * - `action` *(String)*: type of action, can be `setItem`, `removeItem` or\n * `clear`, defaults to `setItem`.\n * - `key` *(String)*: storage key.\n * - `value` *(String)*: storage value.\n *\n * **responseCollection**. The **`responseCollection`** is an Object that\n * exposes functions to read from local- and sessionStorage.\n *\n * ```js\n * // Returns key of nth localStorage value.\n * responseCollection.local.getKey(n)\n * // Returns localStorage value of `key`.\n * responseCollection.local.getItem(key)\n * ```\n *\n * @param request$ - a stream of write request objects.\n * @return {Object} the response collection containing functions\n * for reading from storage.\n * @function storageDriver\n */\nfunction storageDriver(request$) {\n    // Execute writing actions.\n    request$.addListener({\n        next: function (request) { return writeToStore_1.default(request); },\n    });\n    // Return reading functions.\n    return responseCollection_1.default(request$);\n}\nexports.default = storageDriver;\n","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","import _extend from 'extend';\n\nvar undefinedv = function (v) { return v === undefined; };\n\nvar number = function (v) { return typeof v === 'number'; };\n\nvar string = function (v) { return typeof v === 'string'; };\n\nvar text = function (v) { return string(v) || number(v); };\n\nvar array = function (v) { return Array.isArray(v); };\n\nvar object = function (v) { return typeof v === 'object' && v !== null; };\n\nvar fun = function (v) { return typeof v === 'function'; };\n\nvar vnode = function (v) { return object(v) && 'sel' in v && 'data' in v && 'children' in v && 'text' in v; };\n\nvar svgPropsMap = { svg: 1, circle: 1, ellipse: 1, line: 1, polygon: 1,\n  polyline: 1, rect: 1, g: 1, path: 1, text: 1 };\n\nvar svg = function (v) { return v.sel in svgPropsMap; };\n\n// TODO: stop using extend here\nvar extend = function () {\n  var objs = [], len = arguments.length;\n  while ( len-- ) objs[ len ] = arguments[ len ];\n\n  return _extend.apply(void 0, [ true ].concat( objs ));\n};\n\nvar assign = function () {\n  var objs = [], len = arguments.length;\n  while ( len-- ) objs[ len ] = arguments[ len ];\n\n  return _extend.apply(void 0, [ false ].concat( objs ));\n};\n\nvar reduceDeep = function (arr, fn, initial) {\n  var result = initial;\n  for (var i = 0; i < arr.length; i++) {\n    var value = arr[i];\n    if (array(value)) {\n      result = reduceDeep(value, fn, result);\n    } else {\n      result = fn(result, value);\n    }\n  }\n  return result\n};\n\nvar mapObject = function (obj, fn) { return Object.keys(obj).map(\n  function (key) { return fn(key, obj[key]); }\n).reduce(\n  function (acc, curr) { return extend(acc, curr); },\n  {}\n); };\n\nvar deepifyKeys = function (obj) { return mapObject(obj,\n  function (key, val) {\n    var dashIndex = key.indexOf('-');\n    if (dashIndex > -1) {\n      var moduleData = {};\n      moduleData[key.slice(dashIndex + 1)] = val;\n      return ( obj = {}, obj[key.slice(0, dashIndex)] = moduleData, obj )\n      var obj;\n    }\n    return ( obj$1 = {}, obj$1[key] = val, obj$1 )\n    var obj$1;\n  }\n); };\n\nvar flatifyKeys = function (obj) { return mapObject(obj,\n  function (mod, data) { return !object(data) ? (( obj = {}, obj[mod] = data, obj )) : mapObject(\n    flatifyKeys(data),\n    function (key, val) { return (( obj = {}, obj[(mod + \"-\" + key)] = val, obj ))\n      var obj; }\n  )\n    var obj; }\n); };\n\nvar omit = function (key, obj) { return mapObject(obj,\n  function (mod, data) { return mod !== key ? (( obj = {}, obj[mod] = data, obj )) : {}\n    var obj; }\n); };\n\n// Const fnName = (...params) => guard ? default : ...\n\nvar createTextElement = function (text$$1) { return !text(text$$1) ? undefined : {\n  text: text$$1,\n  sel: undefined,\n  data: undefined,\n  children: undefined,\n  elm: undefined,\n  key: undefined\n}; };\n\nvar considerSvg = function (vnode$$1) { return !svg(vnode$$1) ? vnode$$1 :\n  assign(vnode$$1,\n    { data: omit('props', extend(vnode$$1.data,\n      { ns: 'http://www.w3.org/2000/svg', attrs: omit('className', extend(vnode$$1.data.props,\n        { class: vnode$$1.data.props ? vnode$$1.data.props.className : undefined }\n      )) }\n    )) },\n    { children: undefinedv(vnode$$1.children) ? undefined :\n      vnode$$1.children.map(function (child) { return considerSvg(child); })\n    }\n  ); };\n\nvar considerData = function (data) {\n  return !data.data ? data : mapObject(data, function (mod, data) {\n    var key = mod === 'data' ? 'dataset' : mod;\n    return (( obj = {}, obj[key] = data, obj ))\n    var obj;\n  })\n};\n\nvar considerAria = function (data) { return data.attrs || data.aria ? omit('aria',\n  assign(data, {\n    attrs: extend(data.attrs, data.aria ? flatifyKeys({ aria: data.aria }) : {})\n  })\n) : data; };\n\nvar considerProps = function (data) { return mapObject(data,\n  function (key, val) { return object(val) ? ( obj = {}, obj[key] = val, obj ) :\n    { props: ( obj$1 = {}, obj$1[key] = val, obj$1 ) }\n    var obj;\n    var obj$1; }\n); };\n\nvar rewritesMap = { for: 1, role: 1, tabindex: 1 };\n\nvar considerAttrs = function (data) { return mapObject(data,\n    function (key, data) { return !(key in rewritesMap) ? ( obj = {}, obj[key] = data, obj ) : {\n      attrs: extend(data.attrs, ( obj$1 = {}, obj$1[key] = data, obj$1 ))\n    }\n      var obj;\n      var obj$1; }\n); };\n\nvar considerKey = function (data) {\n  return 'key' in data ? omit('key', data) : data\n};\n\nvar sanitizeData = function (data) { return considerProps(considerAria(considerData(considerAttrs(considerKey(deepifyKeys(data)))))); };\n\nvar sanitizeText = function (children) { return children.length > 1 || !text(children[0]) ? undefined : children[0]; };\n\nvar sanitizeChildren = function (children) { return reduceDeep(children, function (acc, child) {\n  var vnode$$1 = vnode(child) ? child : createTextElement(child);\n  acc.push(vnode$$1);\n  return acc\n}\n, []); };\n\nvar createElement = function (sel, data) {\n  var children = [], len = arguments.length - 2;\n  while ( len-- > 0 ) children[ len ] = arguments[ len + 2 ];\n\n  if (fun(sel)) {\n    return sel(data || {}, children)\n  }\n  var text$$1 = sanitizeText(children);\n  return considerSvg({\n    sel: sel,\n    data: data ? sanitizeData(data) : {},\n    children: text$$1 ? undefined : sanitizeChildren(children),\n    text: text$$1,\n    elm: undefined,\n    key: data ? data.key : undefined\n  })\n};\n\nvar index = {\n  createElement: createElement\n};\n\nexport { createElement };export default index;\n","/**\n * Utility function to filter actions by key with type narrowing\n */\nexport const ofType =\n  <T extends { key: string }, K extends string>(key: K) =>\n  (action: T): action is Extract<T, { key: K }> => {\n    return action.key == key;\n  };\n\n/**\n * Another simple utility function which filters by the value\n */\nexport const is =\n  <T>(x: T) =>\n  (y: T) =>\n    x === y;\n\n/**\n * Check if a value is defined\n */\nexport const isDefined = <T>(x: T): x is Exclude<T, undefined> =>\n  x !== undefined;\n","import xs, { Stream } from \"xstream\";\nimport { div, span, input, DOMSource, VNode } from \"@cycle/dom\";\n\nexport type Value = number;\n\nexport interface Props {\n  initial: Value;\n  label: string;\n  min: number;\n  max: number;\n  progress?: number;\n}\n\nexport interface Sources {\n  DOM: DOMSource;\n  props$: Stream<Props>;\n}\n\nexport interface Sinks {\n  DOM: Stream<VNode>;\n  value: Stream<Value>;\n  changes: Stream<Value>;\n}\n\nfunction intent(domSource: DOMSource): Stream<Value> {\n  return domSource\n    .select(\".slider\")\n    .events(\"input\")\n    .map((ev: any) => ev.target.value);\n}\n\nfunction model(newValue$: Stream<Value>, props$: Stream<Props>): Stream<Value> {\n  const initialValue$ = props$.map((props) => props.initial).take(1);\n  return xs.merge(initialValue$, newValue$).remember();\n}\n\nfunction view(props$: Stream<Props>, valueChange$: Stream<Value>) {\n  const value$ = xs.merge(\n    props$.map((props) => props.initial),\n    valueChange$\n  );\n  const progress$ = props$.map((props) =>\n    Math.floor(((props.progress || 0) / props.max) * 100)\n  );\n\n  return xs.combine(props$, value$, progress$).map(([props, value, p]) =>\n    div(\".labeled-slider\", [\n      span(\".label\", props.label),\n      input(\".slider\", {\n        attrs: {\n          type: \"range\",\n          min: props.min,\n          max: props.max,\n          value,\n          style: `--p: ${p}%`,\n        },\n      }),\n    ])\n  );\n}\n\nexport const LabeledSlider = (sources: Sources): Sinks => {\n  const change$ = intent(sources.DOM);\n  const value$ = model(change$, sources.props$);\n  const vdom$ = view(sources.props$, value$);\n  return {\n    DOM: vdom$,\n    value: value$,\n    changes: change$,\n  };\n};\n","import xs, { Stream } from \"xstream\";\nimport { div, label, span, input, DOMSource, VNode } from \"@cycle/dom\";\n\nexport type Value = boolean;\n\nexport interface Props {\n  initial: Value;\n  label: any;\n}\n\nexport interface Sources {\n  DOM: DOMSource;\n  props$: Stream<Props>;\n}\n\nexport interface Sinks {\n  DOM: Stream<VNode>;\n  checked: Stream<Value>;\n  changes: Stream<Value>;\n}\n\nfunction intent(domSource: DOMSource): Stream<Value> {\n  return domSource\n    .select(\".checkbox\")\n    .events(\"input\")\n    .map((ev: any) => ev.target.checked);\n}\n\nfunction model(newValue$: Stream<Value>, props$: Stream<Props>): Stream<Value> {\n  const initialValue$ = props$.map(props => props.initial).take(1);\n  return xs.merge(initialValue$, newValue$).remember();\n}\n\nfunction view(props$: Stream<Props>, value$: Stream<Value>) {\n  return xs.combine(props$, value$).map(([props, value]) =>\n    label(\".toggle-button\", [\n      input(\".checkbox\", {\n        attrs: {\n          type: \"checkbox\",\n          checked: value\n        }\n      }),\n      div(\n        {\n          attrs: {\n            class: [\"caption\"]\n          }\n        },\n        props.label\n      )\n    ])\n  );\n}\n\nexport const ToggleButton = (sources: Sources): Sinks => {\n  const change$ = intent(sources.DOM);\n  const value$ = model(change$, sources.props$);\n  const vdom$ = view(sources.props$, value$);\n  return {\n    DOM: vdom$,\n    checked: value$,\n    changes: change$\n  };\n};\n","import * as Snabbdom from \"snabbdom-pragma\";\n\nimport { DOMSource, MainDOMSource, VNode } from \"@cycle/dom\";\nimport isolate from \"@cycle/isolate\";\nimport xs, { Stream } from \"xstream\";\nimport { is } from \"../utils\";\nimport { LabeledSlider } from \"./LabeledSlider\";\nimport { ToggleButton } from \"./ToggleButton\";\n\nexport interface Props {\n  initialVolume: number;\n  initialThreshold: number;\n  loudness: number;\n}\n\nexport interface Sources {\n  DOM: DOMSource;\n  props: Stream<Props>;\n}\n\nexport interface Sinks {\n  DOM: Stream<VNode>;\n  volume: Stream<number>;\n  threshold: Stream<number>;\n  started: Stream<boolean>;\n}\n\nexport function Main(sources: Sources): Sinks {\n  const helpVisible$ = (sources.DOM.select(\".help-button\") as MainDOMSource)\n    .events(\"click\")\n    .fold((isShown) => !isShown, false);\n  const helpShown$ = helpVisible$.filter(is(true)).take(1).startWith(false);\n  const loudness$ = sources.props.map((props) => props.loudness).debug();\n  const initialVolume$ = sources.props.map((props) => props.initialVolume);\n  const initialThreshold$ = sources.props.map(\n    (props) => props.initialThreshold\n  );\n\n  const VolumeSlider = isolate(LabeledSlider) as typeof LabeledSlider;\n  const ThresholdSlider = isolate(LabeledSlider) as typeof LabeledSlider;\n\n  const volumeSliderProps$ = initialVolume$.map((value) => ({\n    label: \"Feedback Volume\",\n    min: 0,\n    max: 100,\n    initial: value,\n  }));\n  const thresholdSliderProps$ = xs\n    .combine(initialThreshold$, loudness$)\n    .map(([value, loudness]) => ({\n      label: \"Amplitude Threshold\",\n      min: 0,\n      max: 100,\n      initial: value,\n      progress: loudness,\n    }));\n  const toggleButtonProps$ = xs.of(false).map((value) => ({\n    label: (\n      <svg viewBox=\"0 0 24 24\">\n        <path d=\"M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z\" />\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n      </svg>\n    ),\n    initial: value,\n  }));\n\n  const volumeSlider = VolumeSlider({\n    DOM: sources.DOM,\n    props$: volumeSliderProps$,\n  });\n  const thresholdSlider = ThresholdSlider({\n    DOM: sources.DOM,\n    props$: thresholdSliderProps$,\n  });\n  const toggleButton = ToggleButton({\n    DOM: sources.DOM,\n    props$: toggleButtonProps$,\n  });\n\n  const vdom$ = xs\n    .combine(\n      helpShown$,\n      helpVisible$,\n      volumeSlider.DOM,\n      thresholdSlider.DOM,\n      toggleButton.DOM\n    )\n    .map(\n      ([\n        helpShown,\n        helpVisible,\n        volumeSliderDOM,\n        thresholdSliderDOM,\n        toggleButtonDOM,\n      ]) => (\n        <main>\n          <header>\n            <h1 className=\"title\">Repeater</h1>\n            <a className=\"help-button\" aria-label=\"About\">\n              <svg viewBox=\"0 0 24 24\">\n                <path fill=\"none\" d=\"M0 0h24v24H0z\" />\n                <path d=\"M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z\" />\n              </svg>\n            </a>\n          </header>\n          {helpShown && (\n            <section className={`help ${helpVisible ? \"\" : \"help-hidden\"}`}>\n              <p>\n                Repeater listens to your speech and plays it back automatically.\n                It helps practice shadowing technique for language learning and\n                improving pronunciation.\n              </p>\n              <p>\n                Open a video, like TED talk, and repeat after the speaker as\n                closely in time, rhythm, and intonation as possible. Pause the\n                video, and compare it to your own speech.\n              </p>\n              <div className=\"embedded-video\">\n                <iframe\n                  src=\"https://www.youtube-nocookie.com/embed/u5JseMqoQCg?rel=0\"\n                  frameborder=\"0\"\n                  allow=\"autoplay; encrypted-media\"\n                  allowfullscreen\n                />\n              </div>\n              <p>\n                Using headphones is recommended to avoid interference from the\n                speakers. Recorded audio never leaves your browser. For more\n                information about the shadowing technique, see the above video.\n              </p>\n            </section>\n          )}\n          <section className=\"volume-slider\">{volumeSliderDOM}</section>\n          <section className=\"threshold-slider\">{thresholdSliderDOM}</section>\n          <section className=\"toggle-button\">{toggleButtonDOM}</section>\n          <footer>\n            <a\n              className=\"social-link\"\n              href=\"https://github.com/mpontus/repeater\"\n            >\n              <svg\n                viewBox=\"0 0 16 16\"\n                width=\"16\"\n                height=\"16\"\n                aria-hidden=\"true\"\n              >\n                <path\n                  fill-rule=\"evenodd\"\n                  d=\"M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z\"\n                />\n              </svg>\n              <span>Fork me on GitHub</span>\n            </a>\n          </footer>\n        </main>\n      )\n    );\n\n  return {\n    DOM: vdom$,\n    volume: volumeSlider.value,\n    threshold: thresholdSlider.value,\n    started: toggleButton.checked,\n  };\n}\n","import { Driver } from \"@cycle/run\";\nimport xs, { Stream } from \"xstream\";\n\nexport type AudioSink = Stream<\n  | { type: \"set_volume\"; data: number }\n  | { type: \"start_recording\" }\n  | { type: \"stop_recording\" }\n  | { type: \"start_playing\"; data: Float32Array }\n  | { type: \"stop_playing\" }\n>;\n\nexport interface AudioSource {\n  sampleRate: Stream<number>;\n  samples: Stream<Float32Array>;\n}\n\nexport class CancelableMediaSource {\n  private readonly analyserNode: AnalyserNode;\n  private readonly scriptProcessorNode: ScriptProcessorNode;\n  private readonly muteNode: GainNode;\n  private mediaStreamPromise: Promise<MediaStream>;\n  private canceled: boolean = false;\n\n  public readonly samples: Stream<Float32Array>;\n\n  get analyser(): AnalyserNode {\n    return this.analyserNode;\n  }\n\n  constructor(private readonly audioCtx: AudioContext) {\n    this.analyserNode = audioCtx.createAnalyser();\n    this.scriptProcessorNode = audioCtx.createScriptProcessor(4096, 1, 1);\n    this.muteNode = audioCtx.createGain();\n\n    this.analyserNode.connect(this.scriptProcessorNode);\n    this.scriptProcessorNode.connect(this.muteNode);\n    this.muteNode.connect(audioCtx.destination);\n    this.muteNode.gain.value = 0;\n\n    this.samples = xs.create({\n      start: (listener) => {\n        this.scriptProcessorNode.onaudioprocess = (e: AudioProcessingEvent) => {\n          const { inputBuffer } = e;\n          const data = inputBuffer.getChannelData(0);\n\n          listener.next(data);\n        };\n      },\n      stop: () => {\n        this.scriptProcessorNode.onaudioprocess = () => {};\n      },\n    });\n  }\n\n  start(): void {\n    this.mediaStreamPromise = navigator.mediaDevices.getUserMedia({\n      audio: true,\n    });\n    this.mediaStreamPromise.then((stream) => {\n      if (!this.canceled) {\n        const source = this.audioCtx.createMediaStreamSource(stream);\n\n        source.connect(this.analyserNode);\n      }\n    });\n  }\n\n  stop(): void {\n    if (this.canceled) {\n      return;\n    }\n\n    this.canceled = true;\n    this.mediaStreamPromise.then((stream) =>\n      stream.getTracks().forEach((track) => track.stop())\n    );\n  }\n}\n\nexport class PlaybackSource {\n  private readonly analyserNode: AnalyserNode;\n  private readonly volumeControlNode: GainNode;\n  private bufferSource: AudioBufferSourceNode | null = null;\n\n  get analyser(): AnalyserNode {\n    return this.analyserNode;\n  }\n\n  constructor(private readonly audioCtx: AudioContext) {\n    this.analyserNode = audioCtx.createAnalyser();\n    this.volumeControlNode = audioCtx.createGain();\n\n    this.analyserNode.connect(this.volumeControlNode);\n    this.volumeControlNode.connect(audioCtx.destination);\n  }\n\n  start(buffer: Float32Array): void {\n    const audioBuffer = this.audioCtx.createBuffer(\n      1,\n      buffer.length,\n      this.audioCtx.sampleRate\n    );\n    audioBuffer.copyToChannel(buffer, 0, 0);\n\n    this.bufferSource = this.audioCtx.createBufferSource();\n    this.bufferSource.buffer = audioBuffer;\n    this.bufferSource.connect(this.analyserNode);\n    this.bufferSource.start();\n  }\n\n  stop(): void {\n    if (this.bufferSource != null) {\n      this.bufferSource.stop();\n    }\n  }\n\n  set_volume(value: number): void {\n    this.volumeControlNode.gain.value = value;\n  }\n}\n\nexport const makeAudioDriver =\n  (createAudioContext: () => AudioContext): Driver<AudioSink, AudioSource> =>\n  (source$) => {\n    const audioCtx$ = source$\n      .filter((action) => action.type === \"start_recording\")\n      .map(createAudioContext);\n    const mediaSource$ = audioCtx$.map(\n      (audioCtx) => new CancelableMediaSource(audioCtx)\n    );\n    const playbackSource$ = audioCtx$.map(\n      (audioCtx) => new PlaybackSource(audioCtx)\n    );\n\n    xs.combine(source$, mediaSource$, playbackSource$).subscribe({\n      next([action, mediaSource, playbackSource]) {\n        switch (action.type) {\n          case \"set_volume\":\n            playbackSource.set_volume(action.data);\n            break;\n          case \"start_recording\":\n            mediaSource.start();\n            break;\n          case \"stop_recording\":\n            mediaSource.stop();\n            break;\n          case \"start_playing\":\n            playbackSource.start(action.data);\n            break;\n          case \"stop_playing\":\n            playbackSource.stop();\n            break;\n        }\n      },\n    });\n\n    return {\n      sampleRate: audioCtx$.map((audioCtx) => audioCtx.sampleRate),\n      samples: mediaSource$.map((mediaSource) => mediaSource.samples).flatten(),\n    };\n  };\n","import { Driver } from \"@cycle/run\";\nimport xs, { Stream } from \"xstream\";\n\nexport const makeWorkerDriver =\n  <I, O>(worker: Worker): Driver<Stream<I>, Stream<O>> =>\n  (input$) => {\n    input$.addListener({\n      next: (e) => worker.postMessage(e),\n    });\n\n    return xs.createWithMemory({\n      start: (listener) => {\n        worker.onmessage = (e) => {\n          listener.next(e.data);\n        };\n      },\n      stop: () => {\n        worker.onmessage = () => {};\n      },\n    });\n  };\n","import { DOMSource, VNode, makeDOMDriver } from \"@cycle/dom\";\nimport { run } from \"@cycle/run\";\nimport storageDriver, {\n  ResponseCollection,\n  StorageRequest,\n} from \"@cycle/storage\";\nimport xs, { Stream } from \"xstream\";\nimport { Main } from \"./components/Main\";\nimport { AudioSink, AudioSource, makeAudioDriver } from \"./drivers/audioDriver\";\nimport { makeWorkerDriver } from \"./drivers/workerDriver\";\nimport { is, isDefined, ofType } from \"./utils\";\nimport { InputWorkerEvent, OutputWorkerEvent } from \"./worker\";\n\nexport type Sources = {\n  DOM: DOMSource;\n  storage: ResponseCollection;\n  audio: AudioSource;\n  worker: Stream<OutputWorkerEvent>;\n};\n\nexport type Sinks = {\n  DOM: Stream<VNode>;\n  storage: Stream<StorageRequest>;\n  audio: AudioSink;\n  worker: Stream<InputWorkerEvent>;\n};\n\n/**\n * Adjust threshold value to fit real scale.\n *\n * Exponentiation makes the slider feel more natural.\n */\nconst exponentiateThreshold = (v: number) => v ** 2 * 0.2;\nconst unexponentiateThreshold = (v: number) => Math.sqrt(v / 0.2);\n\nconst main = (sources: Sources): Sinks => {\n  const initialVolume$ = sources.storage.local\n    .getItem<string>(\"volume\")\n    .take(1)\n    .map((value) => (value ? parseInt(value, 10) : 50));\n  const initialThreshold = sources.storage.local\n    .getItem<string>(\"threshold\")\n    .take(1)\n    .map((value) => (value ? parseInt(value, 10) : 15));\n  const loudness$ = sources.worker\n    .filter(ofType(\"average_amplitude\"))\n    .map((e) => Math.floor(unexponentiateThreshold(e.data) * 100));\n  const main = Main({\n    DOM: sources.DOM,\n    props: xs\n      .combine(\n        initialVolume$,\n        initialThreshold,\n        xs.merge(\n          loudness$,\n          // Dunno why, but this is necessary to start the stream\n          xs.create({\n            start(listener) {\n              setTimeout(() => listener.next(0));\n            },\n            stop() {},\n          })\n        ) as Stream<number>\n      )\n      .map(([initialVolume, initialThreshold, loudness]) => ({\n        initialThreshold,\n        initialVolume,\n        loudness,\n      })),\n  });\n\n  const vdom$ = main.DOM;\n  const volume$ = main.volume;\n  const threshold$ = main.threshold;\n  const started$ = main.started;\n\n  // We also need explicit changes (i.e. exlude default values) to\n  // invoke driver actions explicitly.\n  const audioSink: AudioSink = xs.merge(\n    started$.filter(is(true)).mapTo({ type: \"start_recording\" }),\n    started$.drop(1).filter(is(false)).mapTo({ type: \"stop_recording\" }),\n    volume$.map((value) => ({ type: \"set_volume\", data: value / 100 })),\n    sources.worker\n      .filter(ofType(\"voice_end\"))\n      .map((e) => ({ type: \"start_playing\", data: e.data })),\n    sources.worker.filter(ofType(\"voice_start\")).mapTo({ type: \"stop_playing\" })\n  );\n\n  const workerSink: Stream<InputWorkerEvent> = xs.merge(\n    started$\n      .filter(is(true))\n      // Nested stream is necessary in order to pass threshold with\n      // \"start\", and not emit \"start\" on every threshold change\n      .map(() =>\n        xs\n          .combine(sources.audio.sampleRate, threshold$)\n          .take(1)\n          .map<InputWorkerEvent>(([sampleRate, threshold]) => ({\n            key: \"start\",\n            data: {\n              sampleRate,\n              amplitudeThreshold: exponentiateThreshold(threshold / 100),\n              silenceDuration: 0.5,\n              contextDuration: 0.5,\n            },\n          }))\n      )\n      .flatten(),\n\n    started$.drop(1).filter(is(false)).mapTo<InputWorkerEvent>({ key: \"stop\" }),\n    threshold$.drop(1).map<InputWorkerEvent>((threshold) => ({\n      key: \"update_settings\",\n      data: {\n        amplitudeThreshold: exponentiateThreshold(threshold / 100),\n      },\n    })),\n    sources.audio.samples.map<InputWorkerEvent>((data) => ({\n      key: \"process\",\n      data,\n    }))\n  );\n\n  const storageSink = xs.merge(\n    volume$.map((value) => ({\n      key: \"volume\",\n      value,\n    })),\n    threshold$.map((value) => ({\n      key: \"threshold\",\n      value,\n    }))\n  );\n\n  return {\n    DOM: vdom$,\n    audio: audioSink,\n    worker: workerSink,\n    storage: storageSink,\n  };\n};\n\nrun(main, {\n  DOM: makeDOMDriver(\"#root\"),\n  storage: storageDriver,\n  audio: makeAudioDriver(() => new AudioContext()),\n  worker: makeWorkerDriver<InputWorkerEvent, OutputWorkerEvent>(\n    new Worker(\"./worker/index.ts\")\n  ),\n});\n"]}